[{"content":"Introduction to Perlin Noise Perlin Noise was developed by Ken Perlin in 1983 for the film Tron as a smooth pseudo-random noise algorithm1. It can generate random patterns with natural-looking texture and is widely used in computer graphics to simulate natural phenomena such as clouds, terrain, fire, wood grain, and water flow2.\nUnlike plain white noise, Perlin Noise has spatial correlation: values at neighboring sample points vary smoothly without abrupt jumps. This smoothness makes the generated textures resemble the continuous variations found in nature.\nMinecraft, for example, uses Perlin Noise as a foundational algorithm to generate its effectively infinite world maps.\nTypes of Noise 1D Uniform White Noise 1D uniform white noise is a one-dimensional noise signal where values follow a uniform distribution.\nimport numpy as np import matplotlib.pyplot as plt def sample_random_points(num_points): # Sampler function: return num_points random numbers in the range [0, 1) return np.random.rand(num_points) def draw_random_strip_image_from_samples(rand_1d, width, height, filename, thickness=1): num_points = len(rand_1d) cols_per_point = width // num_points rand_pos = (rand_1d * (height - 1)).astype(int) img = np.zeros((height, width)) for i, row in enumerate(rand_pos): start_row = max(row - thickness, 0) end_row = min(row + thickness + 1, height) start_col = i * cols_per_point end_col = start_col + cols_per_point img[start_row:end_row, start_col:end_col] = 1 plt.imshow(img, cmap=\u0026#39;gray\u0026#39;, origin=\u0026#39;lower\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.show() plt.imsave(filename, img, cmap=\u0026#39;gray\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: rand_noise = sample_random_points(512) draw_random_strip_image_from_samples(rand_noise, 1024, 512, \u0026#34;random_noise_1d.png\u0026#34;) For one-dimensional random noise, the generated points have no correlation between them.\nIf we use Perlin Noise instead, we get a continuous and smooth curve.\n2D Uniform White Noise If we randomly generate a noise image with a uniform distribution, the result is uniform white noise: each point has no relation to its neighbors.\nimport numpy as np import matplotlib.pyplot as plt # Generate a 512x512 random floating-point grayscale image with values in [0, 1) noise = np.random.rand(512, 512) plt.imshow(noise, cmap=\u0026#39;gray\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.imsave(\u0026#39;random_noise.png\u0026#39;, noise, cmap=\u0026#39;gray\u0026#39;) Completely random white noise:\nPerlin Noise, by contrast, has correlations between neighboring points â€” adjacent values are required to be close and smooth.\nGaussian White Noise import numpy as np import matplotlib.pyplot as plt # Generate 512x512 Gaussian white noise with mean 0.5 and std deviation 0.1 noise = np.random.normal(loc=0.5, scale=0.1, size=(512, 512)) # Clip values to [0, 1] to avoid display artifacts noise = np.clip(noise, 0, 1) plt.imshow(noise, cmap=\u0026#39;gray\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.imsave(\u0026#39;gaussian_white_noise_2d.png\u0026#39;, noise, cmap=\u0026#39;gray\u0026#39;) plt.show() Because it is not uniformly distributed, Gaussian noise often looks a bit softer than uniform white noise.\nThe Gaussian distribution is even more apparent in one dimension, where a clear central band concentrates most of the points.\n1D Perlin Noise To understand the fractal-related concepts in Perlin Noise, we first need to understand the ideas of fade functions, periodicity, and frequency multipliers (octaves)3.\nFade Given a series of known point values, to estimate values between them we can use linear interpolation to produce straight-line segments or cosine interpolation to produce smooth curves.\nCosine interpolation can be written as:\n$$ x = x1 + (x2-x1) * \\frac{1 - \\cos(\\pi \\alpha)}{2} $$\nThe goal of different interpolation methods is to produce a smooth transition rather than a sharp corner. Besides cosine, cubic, quintic, and other polynomials are commonly used.\nConverting linear interpolation into a smooth interpolation like this is called the Fade operation.\nIn the improved version of his noise algorithm, Perlin used the following Fade function:\n$$ t = 6 t^5 - 15 t^4 + 10 t^3 $$\nOctaves If you repeatedly double the sampling frequency, you obtain functions with halved periods. Because doubling frequency corresponds to musical octaves, these levels are called octaves.\nPerlin Noise is composed by mixing noises of different periods with certain weights.\nTypically, periods are doubled while weights are halved, which introduces a fractal-like concept.\n2D Perlin Noise Generator Algorithm Ken Perlin published an implementation of his improved Perlin Noise on his website4.\nPerlin Noise is a grid-based gradient noise function commonly used to generate natural-looking textures and terrain. The two-dimensional implementation proceeds as follows:\n1. Grid partitioning Divide the 2D space into a regular integer grid. Each grid corner (lattice point) is associated with a random gradient vector (often unit vectors uniformly distributed in direction).\n2. Compute the sample point\u0026rsquo;s local position Given a sample point $(x, y)$, determine its containing grid cell by computing the integer coordinates $(X, Y)$ of the cell\u0026rsquo;s lower-left corner:\n$$ X = \\lfloor x \\rfloor, \\quad Y = \\lfloor y \\rfloor $$\nCompute the sample point\u0026rsquo;s local coordinates relative to the lower-left corner:\n$$ x_{\\text{rel}} = x - X, \\quad y_{\\text{rel}} = y - Y $$\n3. Compute dot products between corner gradients and displacement vectors For the four corners of the cell:\n$$ (X, Y),\\ (X+1, Y),\\ (X, Y+1),\\ (X+1, Y+1) $$\nretrieve each corner\u0026rsquo;s gradient vector $\\vec{g}$ and compute the dot product between $\\vec{g}$ and the displacement vector $\\vec{d}$ from the corner to the sample point:\n$$ \\text{dot} = \\vec{g} \\cdot \\vec{d} $$\n4. Smooth interpolation Apply a smooth interpolation function (such as Perlin\u0026rsquo;s fade) along the $x$ and $y$ axes to bilinearly interpolate the four dot products:\n$$ u = \\text{fade}(x_{\\text{rel}}), \\quad v = \\text{fade}(y_{\\text{rel}}) $$\n5. Output noise value The interpolated result is the noise value at the sample point $(x,y)$, typically in the range approximately $[-1, 1]$.\nPython Code Below is an implementation of 2D Perlin Noise in Python.\nimport numpy as np import matplotlib.pyplot as plt permutation = np.array([ 151,160,137,91,90,15, 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23, 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33, 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166, 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244, 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196, 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123, 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42, 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9, 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228, 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107, 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254, 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ], dtype=np.uint16) p = np.tile(permutation, 2) def grad(hash:int, x:float, y:float)-\u0026gt;float: grad_vectors = np.array([ [1, 1], [-1, 1], [1, -1], [-1, -1], [1, 0], [-1, 0], [0, 1], [0, -1] ]) # Normalize gradient vectors grad_vectors = grad_vectors / np.linalg.norm(grad_vectors, axis=1)[:, None] g = grad_vectors[hash % 8] return np.dot(g, [x, y]) def lerp(t: float, a: float, b: float)-\u0026gt;float: return a + t * (b - a) def fade(t: float)-\u0026gt;float: return t * t * t * (t * (t * 6 - 15) + 10) def get_noise(x:float, y:float): X = int(np.floor(x)) \u0026amp; 255 Y = int(np.floor(y)) \u0026amp; 255 x = x % 1 y = y % 1 u = fade(x) v = fade(y) ## Here we only need to ensure the hash values are unique x1 = p[p[X] + Y] x2 = p[p[X+1] + Y] x3 = p[p[X] + Y + 1] x4 = p[p[X+1] + Y + 1] ## x3 x4 ## x1 x2 ## The direction of each vector is from the integer lattice point towards the noise sample point return lerp(v, lerp(u, grad(x1, x, y), grad(x2, x - 1, y)), lerp(u, grad(x3, x, y - 1), grad(x4, x - 1, y - 1))) def get_perlin_noise(width=256, height=256, scale=8.0, octaves=1, persistence=0.5, lacunarity=2.0): noise_arr = np.zeros((height, width), dtype=np.float32) for i in range(height): for j in range(width): for k in range(octaves): x = (j / width) * scale * (lacunarity ** k) y = (i / height) * scale * (lacunarity ** k) noise_arr[i, j] += (persistence ** k) * get_noise(x, y) return noise_arr fig, axs = plt.subplots(2, 2, figsize=(10, 10)) for octave_count, ax in zip(range(1, 5), axs.flatten()): noise_arr = get_perlin_noise(width=256, height=256, scale=8.0, octaves=octave_count) # Optionally normalize to [0, 1] noise_arr = (noise_arr - noise_arr.min()) / (noise_arr.max() - noise_arr.min()) ax.imshow(noise_arr, cmap=\u0026#39;gray\u0026#39;) ax.set_title(f\u0026#39;octaves = {octave_count}\u0026#39;, fontsize=14) ax.axis(\u0026#39;off\u0026#39;) plt.tight_layout() plt.savefig(\u0026#39;perlin_noise_octaves_1_to_4.png\u0026#39;) How to improve gradient values Using fixed gradient directions instead of gradients produced by a fully uniform random hash helps avoid directional bias that degrades the natural appearance5.\nIn the original approach, gradient directions were uniformly distributed over the sphere. However, a cube is not a sphere: projections along coordinate axes are shorter while diagonal directions are longer.\nThis asymmetry in direction can cause a sparse clustering effect: when several nearby gradients that are nearly axis-aligned happen to point the same way, those regions can show anomalously high values.\nIn his improved version, Perlin suggested choosing gradients like:\n$$ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1) $$\nTo avoid the cost of dividing by 12, he expanded the set to 16 directions by adding $(1,1,0),(-1,1,0),(0,-1,1),(0,-1,-1)$.\nThis article follows that idea: it uses eight planar directions for gradients, and each gradient is normalized to unit length.\nFor one-dimensional Perlin Noise, you can omit normalization to increase variation. A 1D Perlin Noise can be seen as sampling a 2D Perlin Noise along a line through the lattice; lattice points off the line have zero weight and the result is equivalent to the 1D case. In that situation, the projection of a diagonal gradient onto the horizontal axis is not 1 but $\\frac{\\sqrt{2}}{2}$.\nImproving the Fade function Perlin5 proposed replacing the fade function with a smoother polynomial (the quintic above).\nThe reason is: if the second derivative is not smooth, when used to displace surfaces you can see obvious blocky artifacts.\nSo it\u0026rsquo;s best to follow these principles:\nAt 0 and 1, derivatives should be 0 so transitions are as smooth as possible. Higher-order derivatives can also be made zero. $ f(0) = 0 $ $ f(1) = 1 $ Examples / Applications Python Noise Library In practice, you rarely need to implement Perlin Noise from scratch â€” the Python noise library can generate Perlin Noise directly.\nimport numpy as np import matplotlib.pyplot as plt from noise import pnoise2 width, height = 512, 512 scale = 64.0 # Controls the \u0026#34;stretch\u0026#34; of the noise; larger values make changes occur more slowly octaves = 6 persistence = 0.5 lacunarity = 2.0 noise = np.zeros((height, width)) for y in range(height): for x in range(width): nx = x / scale ny = y / scale noise[y][x] = pnoise2(nx, ny, octaves=octaves, persistence=persistence, lacunarity=lacunarity, repeatx=1024, repeaty=1024, base=0) # Perlin noise is typically in approximately [-1, 1]; normalize to [0, 1] noise = (noise - noise.min()) / (noise.max() - noise.min()) plt.imshow(noise, cmap=\u0026#39;gray\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.imsave(\u0026#39;perlin_noise_2d_lib.png\u0026#39;, noise, cmap=\u0026#39;gray\u0026#39;) plt.show() Because it is optimized, generation is very fast:\nClouds Use Perlin Noise to simulate simple cloud textures.\nSimulate the dissipating edges of clouds. Simulate central highlights; above a threshold, values remain unchanged, and within a certain range apply the following operation: $$ \\text{Intensity} = \\max(\\text{Intensity} - 40, 0) $$\nimport numpy as np from PIL import Image # Read grayscale image, keep integer values in 0~255 img = Image.open(\u0026#39;perlin_noise_2d_lib.png\u0026#39;).convert(\u0026#39;L\u0026#39;) arr = np.array(img).astype(np.int32) # 0~255 height, width = arr.shape # Create an RGB image, pure blue background (R,G,B) = (0,0,255) rgb_img = np.zeros((height, width, 3), dtype=np.uint8) for y in range(height): for x in range(width): r, g, b = 0, 0, 255 cloud_intensity = arr[y, x] # 0~255 cloud_intensity = cloud_intensity - 30 if cloud_intensity \u0026lt; 100: cloud_intensity = max(cloud_intensity - 40, 0) # Linear blend: cloud_intensity represents white cloud strength (0~255) # Compute weight: cloud_intensity / 255 w = cloud_intensity / 255 r = int(r * (1 - w) + w * 255) g = int(g * (1 - w) + w * 255) b = int(b * (1 - w) + w * 255) rgb_img[y, x, 0] = r rgb_img[y, x, 1] = g rgb_img[y, x, 2] = b # Save the uint8 array directly im = Image.fromarray(rgb_img) im.save(\u0026#39;perlin_cloud.png\u0026#39;) Cloud result:\nPerlin, K. (1985). An image synthesizer. ACM Siggraph Computer Graphics, 19(3), 287-296.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPerlin Noise wiki, https://en.wikipedia.org/wiki/Perlin_noise\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRoger Eastman. (2019). CMSC425.01 Spring 2019 Lecture 20: Perlin noise I. University of Maryland. https://www.cs.umd.edu/class/spring2019/cmsc425/handouts/CMSC425Day20.pdf\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKen Perlin. (2022). Improved Noise reference implementation. https://mrl.cs.nyu.edu/~perlin/noise/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPerlin, K. (2002, July). Improving noise. In Proceedings of the 29th annual conference on Computer graphics and interactive techniques (pp. 681-682).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://cronrpc.github.io/en/posts/perlin-noise-generator/","summary":"\u003ch2 id=\"introduction-to-perlin-noise\"\u003eIntroduction to Perlin Noise\u003c/h2\u003e\n\u003cp\u003ePerlin Noise was developed by Ken Perlin in 1983 for the film \u003cem\u003eTron\u003c/em\u003e as a smooth pseudo-random noise algorithm\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e. It can generate random patterns with natural-looking texture and is widely used in computer graphics to simulate natural phenomena such as clouds, terrain, fire, wood grain, and water flow\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e\n\u003cp\u003eUnlike plain white noise, Perlin Noise has spatial correlation: values at neighboring sample points vary smoothly without abrupt jumps. This smoothness makes the generated textures resemble the continuous variations found in nature.\u003c/p\u003e","title":"Perlin Noise Generator"},{"content":"This article focuses solely on the following topics:\nTransition from trigonometric series expansion to the Euler form of the Fourier transform What the Discrete Fourier Transform is What the 2D Fourier Transform is Explanation of the 2D Discrete Fourier Transform from the 2D Fourier Transform How to perform a 2D Fourier transform on an image Periodicity issues in the 2D Fourier transform Understanding the centering of the 2D frequency spectrum from the periodicity of the 2D Fourier transform Fourier Series A Fourier series is a mathematical tool that represents a periodic function as an infinite sum of sines and cosines.\nTrigonometric Series Expansion The Fourier transform was originally based on the trigonometric series expansion: a periodic function can be expressed as a linear combination of sine and cosine functions:\n$$ f(t) = a_0 + \\sum_{n=1}^{\\infty} a_n \\cos(n\\omega_0 t) + b_n \\sin(n\\omega_0 t) $$\nwhere $\\omega_0 = \\frac{2\\pi}{T}$ is the fundamental frequency.\nComplex Exponential Form Using Eulerâ€™s formulas:\n$$ \\cos(x) = \\frac{e^{ix} + e^{-ix}}{2}, \\quad \\sin(x) = \\frac{e^{ix} - e^{-ix}}{2i} $$\nthe Fourier series can be rewritten in the complex exponential form:\n$$ f(t) = \\sum_{n=-\\infty}^{\\infty} c_n e^{in\\omega_0 t} $$\nwhere $c_n$ are complex coefficients that encapsulate both sine and cosine information. The Euler form is more symmetric and easier to manipulate, and it lays the foundation for generalizing to continuous and multidimensional cases.\nHere, the index $n$ runs from $-\\infty$ to $\\infty$.\nDiscrete Fourier Transform (DFT) The Discrete Fourier Transform is a crucial branch of Fourier analysis. It converts a finite-length discrete signal (typically digital) from the time or spatial domain into the frequency domain, representing it as a sum of complex frequency components.\nIn practice, we work with finite, discrete data. The DFT is defined as:\n$$ X[k] = \\sum_{n=0}^{N-1} x[n] \\cdot e^{-i \\frac{2\\pi}{N}kn}, \\quad k = 0, 1, \\dots, N-1 $$\nThe corresponding inverse transform is:\n$$ x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\cdot e^{i \\frac{2\\pi}{N}kn} $$\nThe DFT maps the time-domain signal $x[n]$ to the frequency-domain $X[k]$, where each $X[k]$ corresponds to the amplitude and phase of a specific frequency component.\nNegative Frequencies and Periodic Reordering In the DFT, negative frequencies naturally arise.\nAlthough the DFT index $k$ is a non-negative integer, the Fourier frequencies exhibit periodicity modulo $N$:\n$$ e^{-i \\frac{2\\pi}{N} k n} = e^{-i \\frac{2\\pi}{N} (k + mN) n}, \\quad \\forall m \\in \\mathbb{Z} $$\nThus, frequency $k = N - 1$ is equivalent to $-1$, $k = N - 2$ to $-2$, and so on.\nWe can reinterpret the frequency indices to span from negative to positive frequencies:\n$$ k = -\\frac{N}{2}, \\dots, -1, 0, 1, \\dots, \\frac{N}{2} - 1 \\quad (\\text{for even } N) $$\nBy reordering (or centering) the spectrum, the result aligns more intuitively with symmetric positive and negative frequency components.\nAfter applying a 2D Fourier transform to an image, we often center the spectrum so that low-frequency components appear at the center.\n2D Fourier Transform The Fourier transform can be extended from the 1D case to 2D.\nWhat Is the 2D Fourier Transform? The continuous 2D Fourier transform of a function $f(x, y)$ is defined as:\n$$ F(u, v) = \\iint_{-\\infty}^{\\infty} f(x, y) \\cdot e^{-i2\\pi (ux + vy)} , dx,dy $$\nIts inverse is:\n$$ f(x, y) = \\iint_{-\\infty}^{\\infty} F(u, v) \\cdot e^{i2\\pi (ux + vy)} , du,dv $$\nHere, $(x, y)$ are spatial-domain coordinates and $(u, v)$ are frequency-domain coordinates. The transform $F(u, v)$ describes the amplitude and phase of each frequency component in the signal.\n2D Discrete Fourier Transform For a discrete $M \\times N$ function $f[m, n]$, the 2D DFT is defined as:\n$$ F[k, l] = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f[m, n] \\cdot e^{-i 2\\pi \\left( \\frac{km}{M} + \\frac{ln}{N} \\right)} $$\nThe inverse 2D DFT is:\n$$ f[m, n] = \\frac{1}{MN} \\sum_{k=0}^{M-1} \\sum_{l=0}^{N-1} F[k, l] \\cdot e^{i 2\\pi \\left( \\frac{km}{M} + \\frac{ln}{N} \\right)} $$\nPeriodicity of the 2D Fourier Transform Like the 1D DFT, the 2D DFT is periodic:\n$$ F[k + M, l] = F[k, l], \\quad F[k, l + N] = F[k, l] $$\nThis means the spectrum repeats in both horizontal and vertical directions.\nThe frequency indices $k$ and $l$ range from $0$ to $M-1$ and $0$ to $N-1$, but these indices are understood modulo the respective dimensions. For example, when $k \u0026gt; \\tfrac{M}{2}$, the actual frequency corresponds to the negative frequency $k - M$. The same applies for $l \u0026gt; \\tfrac{N}{2}$.\nHow to Perform a 2D Fourier Transform on an Image In Python, libraries like NumPy or OpenCV make it easy to compute a 2D Fourier transform. For example, using NumPy:\nimport numpy as np import matplotlib.pyplot as plt from PIL import Image # Load and convert the image to grayscale img = Image.open(\u0026#39;doge.jpg\u0026#39;).convert(\u0026#39;L\u0026#39;) f = np.array(img) # Compute the 2D Fourier transform F = np.fft.fft2(f) # Magnitude and phase spectra magnitude_spectrum = np.abs(F) phase_spectrum = np.angle(F) log_magnitude = np.log(1 + magnitude_spectrum) # Create subplots fig, axs = plt.subplots(1, 3, figsize=(15, 5)) # Original image axs[0].imshow(f, cmap=\u0026#39;gray\u0026#39;) axs[0].set_title(\u0026#39;Original Image\u0026#39;) axs[0].axis(\u0026#39;off\u0026#39;) # Magnitude spectrum axs[1].imshow(log_magnitude, cmap=\u0026#39;gray\u0026#39;) axs[1].set_title(\u0026#39;Magnitude Spectrum (log)\u0026#39;) axs[1].axis(\u0026#39;off\u0026#39;) # Phase spectrum im = axs[2].imshow(phase_spectrum, cmap=\u0026#39;gray\u0026#39;) axs[2].set_title(\u0026#39;Phase Spectrum\u0026#39;) axs[2].axis(\u0026#39;off\u0026#39;) # Add a colorbar to the phase spectrum fig.colorbar(im, ax=axs[2], shrink=0.7) plt.tight_layout() plt.show() After running this, you will see the magnitude and phase spectra:\nInverse Transform to Recover the Image (Magnitude + Phase) The Fourier transform results are complex, containing magnitude and phase information. Retaining only one of them is insufficient to reconstruct the original image.\nTo recover the image:\nimport numpy as np import matplotlib.pyplot as plt from PIL import Image # Load and convert the image to grayscale img = Image.open(\u0026#39;doge.jpg\u0026#39;).convert(\u0026#39;L\u0026#39;) f = np.array(img) # Compute the 2D Fourier transform F = np.fft.fft2(f) # Perform the inverse Fourier transform recovered = np.fft.ifft2(F) recovered_real = np.real(recovered) plt.imshow(recovered_real, cmap=\u0026#39;gray\u0026#39;) plt.title(\u0026#39;Recovered Image from IFFT\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.show() The reconstructed image should match the original.\nCentering the Spectrum To observe the frequency distribution more clearly, we often center the spectrum so that low frequencies are in the middle and high frequencies are around the edges.\nYou can use np.fft.fftshift to center the spectrum:\nimport cv2 import numpy as np import matplotlib.pyplot as plt img = cv2.imread(\u0026#39;doge.jpg\u0026#39;, cv2.IMREAD_GRAYSCALE) f = np.fft.fft2(img) fshift = np.fft.fftshift(f) magnitude_spectrum = 20 * np.log(np.abs(fshift) + 1) plt.figure(figsize=(12, 6)) plt.subplot(1, 2, 1) plt.title(\u0026#39;Original Image\u0026#39;) plt.imshow(img, cmap=\u0026#39;gray\u0026#39;) plt.subplot(1, 2, 2) plt.title(\u0026#39;Magnitude Spectrum\u0026#39;) plt.imshow(magnitude_spectrum, cmap=\u0026#39;gray\u0026#39;) plt.show() After centering, the low-frequency components move to the center, making it easier to observe textures and directional patterns.\nHigh-level contours are represented by the low-frequency center, while fine details and textures are captured by the high-frequency components at the edges.\n","permalink":"https://cronrpc.github.io/en/posts/2d-fourier-transform/","summary":"\u003cp\u003eThis article focuses solely on the following topics:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTransition from trigonometric series expansion to the Euler form of the Fourier transform\u003c/li\u003e\n\u003cli\u003eWhat the Discrete Fourier Transform is\u003c/li\u003e\n\u003cli\u003eWhat the 2D Fourier Transform is\u003c/li\u003e\n\u003cli\u003eExplanation of the 2D Discrete Fourier Transform from the 2D Fourier Transform\u003c/li\u003e\n\u003cli\u003eHow to perform a 2D Fourier transform on an image\u003c/li\u003e\n\u003cli\u003ePeriodicity issues in the 2D Fourier transform\u003c/li\u003e\n\u003cli\u003eUnderstanding the centering of the 2D frequency spectrum from the periodicity of the 2D Fourier transform\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"fourier-series\"\u003eFourier Series\u003c/h2\u003e\n\u003cp\u003eA Fourier series is a mathematical tool that represents a periodic function as an infinite sum of sines and cosines.\u003c/p\u003e","title":"2D Fourier Transform"}]