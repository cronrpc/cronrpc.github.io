<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on cronrpc 中文</title>
    <link>https://cronrpc.github.io/zh/posts/</link>
    <description>Recent content in Posts on cronrpc 中文</description>
    <image>
      <title>cronrpc 中文</title>
      <url>https://cronrpc.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://cronrpc.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.147.2</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 12 Nov 2025 15:01:44 +0800</lastBuildDate>
    <atom:link href="https://cronrpc.github.io/zh/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unity Editor Extensions</title>
      <link>https://cronrpc.github.io/zh/posts/unity-editor-extensions/</link>
      <pubDate>Wed, 12 Nov 2025 15:01:44 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/unity-editor-extensions/</guid>
      <description>&lt;p&gt;首先明确一点，编辑器开发的知识还是很多的，正确的学习方式还是从实践入手，用查工具一样的方式去学习使用。&lt;/p&gt;
&lt;h2 id=&#34;1-unity编辑器开发前置知识&#34;&gt;1. Unity编辑器开发前置知识&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是注解attribute&#34;&gt;1.1 什么是注解（Attribute）？&lt;/h3&gt;
&lt;p&gt;注解（Attribute） 是 C# 提供的一种元数据（Metadata）机制，用于在类、方法、字段、属性等上附加额外的信息。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unity AssetBundles and Addressables</title>
      <link>https://cronrpc.github.io/zh/posts/unity-resources-assetbundles-and-addressables/</link>
      <pubDate>Tue, 04 Nov 2025 21:13:49 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/unity-resources-assetbundles-and-addressables/</guid>
      <description>&lt;p&gt;在 Unity 开发中，如何高效管理和加载游戏资源，是决定项目性能和可维护性的重要因素。&lt;/p&gt;
&lt;p&gt;Unity 这些年来先后推出了三种主要的资源加载方式：&lt;/p&gt;
&lt;p&gt;Resources → AssetBundles → Addressables。&lt;/p&gt;
&lt;p&gt;每一代系统都在解决上一代的局限性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unity Tween System 补间动画系统</title>
      <link>https://cronrpc.github.io/zh/posts/unity-tween-system/</link>
      <pubDate>Fri, 17 Oct 2025 14:05:23 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/unity-tween-system/</guid>
      <description>&lt;h2 id=&#34;1-tween-system&#34;&gt;1. Tween System&lt;/h2&gt;
&lt;p&gt;Tween（补间） 是指在两个状态之间，通过时间插值自动生成中间帧（in-between），从而产生平滑过渡的动画或变化。&lt;/p&gt;
&lt;p&gt;因为在游戏中，我们很多时候需要进行插值来表示过渡动画。比如物体从一个点移动到目的地，只需要设定初始值和目的地值，还有所用的时间，那么中间的过程也就确定了，只需要通过计算去获取每个时刻的值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Deferred Rendering Path</title>
      <link>https://cronrpc.github.io/zh/posts/deferred-rendering-path/</link>
      <pubDate>Thu, 18 Sep 2025 23:04:44 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/deferred-rendering-path/</guid>
      <description>&lt;h2 id=&#34;1-unity-render-pipelines&#34;&gt;1. Unity Render Pipelines&lt;/h2&gt;
&lt;h3 id=&#34;11-unity-渲染管线的流程&#34;&gt;1.1 Unity 渲染管线的流程&lt;/h3&gt;
&lt;p&gt;渲染管线是引擎的渲染步骤，也就是游戏引擎把游戏对象转化为图像显示到屏幕上的步骤。&lt;/p&gt;
&lt;p&gt;一个渲染管线大致可以分为下列几个步骤：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unity Input System</title>
      <link>https://cronrpc.github.io/zh/posts/unity-input-system/</link>
      <pubDate>Thu, 11 Sep 2025 13:04:43 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/unity-input-system/</guid>
      <description>&lt;p&gt;一个系统的输入有哪些？&lt;/p&gt;
&lt;p&gt;如果是电脑上，有鼠标、键盘、手柄；主机上主要是手柄；移动设备上则是屏幕、加速度计、陀螺仪。&lt;/p&gt;
&lt;p&gt;除此之外，还有一些比较特殊的反馈，例如PC手柄的基础振动，PS平台的手柄还支持力反馈和吹气，移动端也可以触发手机的振动等。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unity Compute Shader</title>
      <link>https://cronrpc.github.io/zh/posts/unity-compute-shader/</link>
      <pubDate>Sun, 07 Sep 2025 23:16:32 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/unity-compute-shader/</guid>
      <description>&lt;h2 id=&#34;1-compute-shader&#34;&gt;1. Compute Shader&lt;/h2&gt;
&lt;p&gt;通常我们的游戏逻辑是跑在CPU上的，但是有一些非常适合并行计算的操作，比如各种粒子运动、流体/布料模拟、大量 AI 行为等，更适合跑在 GPU 上。这是因为 GPU 的核心数量非常多，天然更适合处理能够进行并行的计算。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Laplace Transform</title>
      <link>https://cronrpc.github.io/zh/posts/laplace-transform/</link>
      <pubDate>Thu, 04 Sep 2025 19:27:16 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/laplace-transform/</guid>
      <description>&lt;h2 id=&#34;1-从傅里叶变换到拉普拉斯变换&#34;&gt;1. 从傅里叶变换到拉普拉斯变换&lt;/h2&gt;
&lt;h3 id=&#34;11-傅里叶变换的局限&#34;&gt;1.1 傅里叶变换的局限&lt;/h3&gt;
&lt;p&gt;傅里叶变换的公式：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
F(\omega) &amp;amp;= \int_{-\infin}^{\infin}{f(t) e^{-j\omega t} dt}
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;其中的指数部分可以写为：&lt;/p&gt;
&lt;p&gt;$$
e^{-jwt}=\cos{wt}-j\sin{wt}
$$&lt;/p&gt;
&lt;p&gt;但是对于函数比如 $f(t) = t^2$ 会发现根本积分不了，因为在无穷范围内积分的结果是无穷。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fourier Transform</title>
      <link>https://cronrpc.github.io/zh/posts/fourier-transform/</link>
      <pubDate>Sun, 31 Aug 2025 12:18:21 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/fourier-transform/</guid>
      <description>&lt;h2 id=&#34;1-傅里叶变换&#34;&gt;1. 傅里叶变换&lt;/h2&gt;
&lt;p&gt;傅里叶变换起源于18世纪研究振动与热传导的问题。欧拉、达朗贝尔和伯努利提出用正弦波描述振动，奠定了思想基础。&lt;/p&gt;
&lt;p&gt;19世纪初，法国数学家傅里叶在研究热传导时提出任何函数都可展开为正弦与余弦级数，这就是傅里叶级数，并逐渐发展为傅里叶变换。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unity Stencil Buffer &amp; Stencil Test</title>
      <link>https://cronrpc.github.io/zh/posts/stencil-buffer-and-stencil-test/</link>
      <pubDate>Fri, 29 Aug 2025 23:01:50 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/stencil-buffer-and-stencil-test/</guid>
      <description>&lt;h2 id=&#34;stencil-介绍&#34;&gt;Stencil 介绍&lt;/h2&gt;
&lt;p&gt;Stencil 的概念和 Stencil Buffer 联系在一起。&lt;/p&gt;
&lt;p&gt;我们知道，屏幕有深度缓冲，在默认情况下，当正在渲染的点的距离大于深度缓冲里的值时，就会直接丢弃此时Pass。&lt;/p&gt;
&lt;p&gt;Stencil Buffer 也是一个 Buffer，不同于深度缓冲有默认的大小对比行为，Stencil Buffer 需要我们手动约定处理方式。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Worley Noise / Voronoi Noise Generator</title>
      <link>https://cronrpc.github.io/zh/posts/worley-noise-generator/</link>
      <pubDate>Mon, 18 Aug 2025 20:50:23 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/worley-noise-generator/</guid>
      <description>&lt;h2 id=&#34;worley-noise&#34;&gt;Worley Noise&lt;/h2&gt;
&lt;p&gt;Worley Noise&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;（也称为 Voronoi noise 和 Cellular noise）是由 Steven Worley&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 在 1996 年引入的一种噪声函数。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;worley noise&#34; loading=&#34;lazy&#34; src=&#34;https://cronrpc.github.io/zh/posts/worley-noise-generator/worley-noise.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;它的样子看起来就是生物细胞的样子，由一个个 cell 构成，作者本身也是叫它“Cellular Texture”。&lt;/p&gt;</description>
    </item>
    <item>
      <title>有符号距离场(SDF)</title>
      <link>https://cronrpc.github.io/zh/posts/signed-distance-field/</link>
      <pubDate>Wed, 13 Aug 2025 20:25:38 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/signed-distance-field/</guid>
      <description>&lt;h2 id=&#34;sdf-介绍&#34;&gt;SDF 介绍&lt;/h2&gt;
&lt;h3 id=&#34;signed-distance-field-sdf&#34;&gt;Signed Distance Field (SDF)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Signed Distance Field&lt;/strong&gt;（有符号距离场）&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;是一种用于表示形状的数学函数或数据结构。&lt;br&gt;
它在二维或三维空间中为每个点分配一个&lt;strong&gt;带符号的距离值&lt;/strong&gt;，表示该点到最近表面（或边界）的距离，并用符号区分内外：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Perlin Noise Generator</title>
      <link>https://cronrpc.github.io/zh/posts/perlin-noise-generator/</link>
      <pubDate>Wed, 06 Aug 2025 21:00:07 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/perlin-noise-generator/</guid>
      <description>&lt;h2 id=&#34;perlin-noise-介绍&#34;&gt;Perlin Noise 介绍&lt;/h2&gt;
&lt;p&gt;Perlin 噪声（Perlin Noise）是由 Ken Perlin 在 1983 年为电影《Tron》开发的一种平滑伪随机噪声算法&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。它能够生成具有自然纹理的随机模式，广泛用于计算机图形学中模拟云彩、地形、火焰、木纹、水流等自然现象&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;与普通白噪声不同，Perlin 噪声具有空间相关性：相邻采样点的值变化平滑，没有突兀的跳变。这种平滑特性使得它生成的纹理更像自然界的连续变化。&lt;/p&gt;</description>
    </item>
    <item>
      <title>2D Fourier Transform</title>
      <link>https://cronrpc.github.io/zh/posts/2d-fourier-transform/</link>
      <pubDate>Fri, 01 Aug 2025 20:49:34 +0800</pubDate>
      <guid>https://cronrpc.github.io/zh/posts/2d-fourier-transform/</guid>
      <description>&lt;p&gt;本文仅聚焦于如下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从三角级数展开，过渡到欧拉形式的傅里叶变换&lt;/li&gt;
&lt;li&gt;什么是离散傅里叶变换&lt;/li&gt;
&lt;li&gt;什么是2D傅里叶变换&lt;/li&gt;
&lt;li&gt;从2D傅里叶变换，解释到2D离散傅里叶变换&lt;/li&gt;
&lt;li&gt;如何对图像进行2D傅里叶变换&lt;/li&gt;
&lt;li&gt;2D傅里叶变换的周期性问题&lt;/li&gt;
&lt;li&gt;从2D傅里叶变换的周期性理解傅里叶2D频谱图的中心化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;傅里叶级数&#34;&gt;傅里叶级数&lt;/h2&gt;
&lt;p&gt;傅里叶级数是一种数学工具，它表示一个周期函数为一组正弦和余弦函数的无穷和。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
