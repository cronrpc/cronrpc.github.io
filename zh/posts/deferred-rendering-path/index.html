<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Deferred Rendering Path | cronrpc 中文</title>
<meta name=keywords content="Unity,Deferred Rendering"><meta name=description content="1. Unity Render Pipelines
1.1 Unity 渲染管线的流程
渲染管线是引擎的渲染步骤，也就是游戏引擎把游戏对象转化为图像显示到屏幕上的步骤。
一个渲染管线大致可以分为下列几个步骤："><meta name=author content="cronrpc"><link rel=canonical href=https://cronrpc.github.io/zh/posts/deferred-rendering-path/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://cronrpc.github.io/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cronrpc.github.io/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cronrpc.github.io/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://cronrpc.github.io/icons/apple-touch-icon.png><link rel=mask-icon href=https://cronrpc.github.io/icons/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://cronrpc.github.io/zh/posts/deferred-rendering-path/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://cronrpc.github.io/zh/posts/deferred-rendering-path/"><meta property="og:site_name" content="cronrpc 中文"><meta property="og:title" content="Deferred Rendering Path"><meta property="og:description" content="1. Unity Render Pipelines 1.1 Unity 渲染管线的流程 渲染管线是引擎的渲染步骤，也就是游戏引擎把游戏对象转化为图像显示到屏幕上的步骤。
一个渲染管线大致可以分为下列几个步骤："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-18T23:04:44+08:00"><meta property="article:modified_time" content="2025-09-18T23:04:44+08:00"><meta property="article:tag" content="Unity"><meta property="article:tag" content="Deferred Rendering"><meta property="og:image" content="https://cronrpc.github.io/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cronrpc.github.io/cover.png"><meta name=twitter:title content="Deferred Rendering Path"><meta name=twitter:description content="1. Unity Render Pipelines
1.1 Unity 渲染管线的流程
渲染管线是引擎的渲染步骤，也就是游戏引擎把游戏对象转化为图像显示到屏幕上的步骤。
一个渲染管线大致可以分为下列几个步骤："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cronrpc.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"Deferred Rendering Path","item":"https://cronrpc.github.io/zh/posts/deferred-rendering-path/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deferred Rendering Path","name":"Deferred Rendering Path","description":"1. Unity Render Pipelines 1.1 Unity 渲染管线的流程 渲染管线是引擎的渲染步骤，也就是游戏引擎把游戏对象转化为图像显示到屏幕上的步骤。\n一个渲染管线大致可以分为下列几个步骤：\n","keywords":["Unity","Deferred Rendering"],"articleBody":"1. Unity Render Pipelines 1.1 Unity 渲染管线的流程 渲染管线是引擎的渲染步骤，也就是游戏引擎把游戏对象转化为图像显示到屏幕上的步骤。\n一个渲染管线大致可以分为下列几个步骤：\n剔除：包括视锥剔除和遮挡剔除（这里的遮挡剔除是指如果物体被另一个物体遮挡就直接剔除，但是通常是固定场景的遮挡进行这种剔除，比如进入房间之后遮挡其他房间，可参考OcclusionCulling。 渲染：绘制物体和它们的光照到相应的像素缓冲（pixel buffer）上。 后处理：修改像素缓冲为最后的输出结果。这一步可以做出一些效果，比如 bloom、景深等。 有时候会把它和图形管线混淆，实际上 Graphics Pipeline 是指下面这个图（来自Vulkan）：\n它是 GPU 中绘制图像的流程，首先变换顶点，然后光栅化，再进行片元着色。它实际上仅仅对应渲染管线中用到的一个功能，也就是 Rendering 这个步骤中的着色。如果你学习图形学知识，主要深入的是图形管线的编写。而 Unity 中我们不仅仅需要关注图形管线，还需要了解整个渲染管线。\n1.2 URP / HDRP / Built-in 官方有提供三种渲染管线：\nURP：属于可编程渲染管线（SRP，Scriptable Render Pipelines），适配不同平台的可扩展的图形。 HDRP：SRP，前沿的高保真的显示效果，通常用于高端设备。 Built-in：通用渲染管线，定制化程度相比 SRP 比较低。 SRP 允许你通过编写 C# 代码来定制上面提到的剔除、渲染和后处理三个步骤，（Built-In 也可以定制修改不过你需要先获得源代码）。除了 URP 和 HDRP，你还可以编写自己的 SRP。\nBuilt-in 是旧版的渲染管线，现在完全不需要去考虑这个，只有一些过去的项目开发者会选择这个。如果现在去学习一些教程，一些2022年以前写的书籍通常会使用这个，而新版的教程视频通常都是采用 URP。\n1.3 Render Target 和 MRT 渲染目标就是渲染结果输出的目标，可以理解为是一块画布，能够往上面写入任何东西。\n渲染目标可以是多个，例如在前向渲染中，最基本的有3个，颜色（RGBA 4通道）、深度、模板（Stencil），当然深度和模板通常都不是4通道的，所以有可能会合并在一张画布上。\n在正向渲染中通常只需要 2 个RT，颜色加 Depth，其中深度是可以配置精度的，比如24位或者32位，以及是否混合 Stencil。\nGPU是可以同时输出多张 Render Target 的，这个特性在图形 API 里叫做 MRT（Multiple Render Targets，多渲染目标）。\n在延迟渲染中，GBuffer同时输出了多个 RT。\n在一次几何遍历中输出了不同的信息用于后续的渲染，例如：\nRT0: 漫反射颜色 (Diffuse Color) RT1: 法线 (Normal) 等 RT2: 镜面反射参数 (Specular, Roughness) RT4: 自定义数据，比如材质ID等 这就是延迟渲染 (Deferred Rendering) 使用 MRT 的原因，如果没有这个特性，需要写几个 Pass，每次 Pass 遍历只是为了获取一张 RT，那样效率就低了。\n2. Render Path 中文可以叫做渲染路径。\n渲染路径是指绘制和照亮相机能看到的游戏对象的系列操作。不同的渲染路径具有不同的功能和性能特点。如果说渲染管线是做饭的一套流程，那么渲染路径可以理解为是放调味品的顺序和时机。比如计算光照的时机到底是在全局深度测试之前，还是全局深度测试之后等。\nUnity支持两种方式：前向渲染（Forward）和延迟渲染（Deferred）以及它们的改进形式。\n这里推荐阅读：毛星云关于延迟渲染的总结1。\n因为 URP 可以同时运行在各种平台上，包括手机，所以通常都是采用 URP 这个管线来开发 Unity 游戏。所以这里不对 HDRP 进行介绍，HDRP 有更多高级功能，支持光线追踪，如果想了解可以去查阅文档。\n2.1 Forward Path 正向渲染是一种传统的图形渲染管线方式。在这种模式下，每个物体都会依次经过顶点着色、光栅化、片元着色等阶段，并且在片元着色器（Fragment Shader）中会直接计算光照和材质效果。\n正向渲染在处理物体的时候，会进行深度测试与着色，先渲染的物体有可能被后渲染的物体覆盖，因为后渲染的物体距离屏幕更近。\n这样在最坏的情况下，所有物体都会经过着色，此时如果有 n 个物体，m 个光源，那么复杂度就是 $O(n * m)$。\n2.2 PrePass / Early-Z 注意，上面提到的是经典的正向渲染，没有考虑 prePass 来先遍历深度等方式。实际上现在的 URP 中的 Forward Path 是会先用 prePass 获取深度，这种情况下复杂度就不能说是 $O(n * m)$，而是 $O(n + m)$。这里的光源计算次数应该是分辨率乘以光照数，但是分辨率通常会认为是个常数。\n前向渲染通过 prePass 方式来处理还是和延迟渲染有区别的，区别在于带宽和遍历次数，按照 prePass 方式有 2 次遍历，按照延迟渲染的方式没有 2 次遍历，不过需要多输出几张 RT。\n还有一种叫做 Early-Z，是在对片元着色（光照计算）之前先进行深度测试，而不是计算之后再判断。现在的 GPU 普遍提供这个技术了。但是这个技术没有 prePass 彻底，它只是避免了近处物体计算后又计算远处物体，但是没有避免先计算远处物体导致的多余计算。\n2.3 Deferred Path 延迟渲染，对比经典的前向渲染，对于多光源的性能效果非常好。\n延迟渲染首先遍历整个场景，进行一次绘制，但是它的输出不是光照后的结果，而是一些基本的信息，比如反照率、法线、高光度等等，输出几张 RT。在全部遍历完毕以后，再对所有像素进行一次遍历，根据 RT 对每个像素进行光照计算。\n我们统称这些 RT 为 GBuffer，实际上就是一个个像素的信息。\n这么来看，延迟渲染就是单纯把光照计算这个部分拿出来了，法线采样、贴图采用次数什么的都没有减少，只是都存起来。\n而前向渲染如果单独把深度测试提取出来，那么整个其实最后计算的光照数量应该和延迟是一样的。但是这样就少用一些图去存储GBuffer，但同时也会多一些遍历次数。\n因为延迟渲染GBuffer生成之后只要遍历pixel，但是如果是深度测试单独提取出来，依然还是需要遍历一次所有物体。\n从下图可以看到，延迟渲染首先渲染了 GBuffer，之后在 Deferred Pass 中进行光照计算，光照计算也是通过多次着色来实现的，每多一个光照就需要多进行一些绘制。\n可以看到，图中处理的方式是，对于每个光源，遍历一次受影响的像素，来进行针对该光源的颜色绘制，这样一个光源一个光源地添加颜色。\n延迟渲染还是要考虑多材质这个问题，例如，上图的地面和方块就不是一个材质。\n解决方法有 2 种，URP 中默认的方式是在 GBuffer 阶段通过 Stencil 标记材质。\n然后在 Deferred Pass 阶段根据 Stencil 来走不同的 Pass 进行绘制。当然你会看到 Stencil Ref 有点差异是因为还有一个上色的过程，这里有一个 Bit 用来标记是否需要上色（是否被某个光照到）。\n另一个方式就是不需要这么多的 Pass，通过在 GBuffer 中使用某些比特位来标记材质，这样在同一个 Pass 中走不同的分支就可以代表不同材质了。\n2.4 Shadow Map 这么多光源，会不会影响性能？除了前面的地 Deferred Pass，阴影部分也是影响性能的地方。\n前面讨论的延迟渲染中，光源是没有阴影的，所以我们只感觉添加一个光就是添加了 一点 Deferred Pass。\n但是如果是下图这种聚光灯效果：\n可以直接穿透物体照射后面的物体。\n原因是我们没有开启光源的阴影，需要在光源的设置中开启它。\n开启之后，光源就会通过 Shadow Map 技术，来生产光源的 Shadow Map，1个点光源通常生成 6 张图，涵盖 6 个方向。\n这时就产生了遮挡关系。\n2.5 半透明物体 延迟渲染中如何渲染半透明物体？答案是在延迟渲染完不透明物体之后，再用前向渲染的方式渲染半透明物体。\n2.6 在延迟渲染中使用前向渲染 如何在延迟渲染中增加一个前向渲染？\n可以通过增加 Render Objects 这样一个 Renderer Features，在某个事件后插入。比如这里选择在渲染透明物体之前渲染。\n当延迟渲染完毕后，还没有渲染物体。\n插入了一个渲染物体的 Pass。\n不用担心光照遮挡问题，因为光照可以设置影响的 Layer，设置正确的话遮挡关系也是会正确的。\n关于插入的位置，基本上 Opaques 之后都是可以的，因为参考Render event，Deferred Pass 发生在 BeforeRenderingOpaques 之前。\n2.7 Forward+ Path 前向+渲染路径与标准的前向渲染路径类似，但没有限制每个游戏对象可以受多少个光源影响。不过，每台摄像机可见光源的数量仍然有限制。\n使用前向+渲染路径减少了Unity为每个游戏对象计算的光源数量。Unity将屏幕划分为多个瓦片，然后确定哪些光源会影响这些瓦片。当Unity计算某个游戏对象的光照时，它只会使用影响该游戏对象所在瓦片的光源。\n每个网格方块是一个瓦片，每个值表示影响该瓦片的灯光数量。\nUnity 在选择 Forward+ 渲染路径时会忽略以下设置：\nURP 资源中的附加灯光。 URP 资源中的主灯光。 URP 资源中附加灯光 \u003e 每个对象限制。 毛星云, 【《Real-Time Rendering 3rd》 提炼总结】(七) 第七章续 · 延迟渲染(Deferred Rendering)的前生今世, https://zhuanlan.zhihu.com/p/28489928 ↩︎\n","wordCount":"3380","inLanguage":"zh","image":"https://cronrpc.github.io/cover.png","datePublished":"2025-09-18T23:04:44+08:00","dateModified":"2025-09-18T23:04:44+08:00","author":{"@type":"Person","name":"cronrpc"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cronrpc.github.io/zh/posts/deferred-rendering-path/"},"publisher":{"@type":"Organization","name":"cronrpc 中文","logo":{"@type":"ImageObject","url":"https://cronrpc.github.io/icons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cronrpc.github.io/zh/ accesskey=h title="cronrpc (Alt + H)"><img src=https://cronrpc.github.io/apple-touch-icon.png alt aria-label=logo height=35>cronrpc</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://cronrpc.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://cronrpc.github.io/zh/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://cronrpc.github.io/zh/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://cronrpc.github.io/zh/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://cronrpc.github.io/zh/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://cronrpc.github.io/zh/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cronrpc.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://cronrpc.github.io/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Deferred Rendering Path</h1><div class=post-meta><span title='2025-09-18 23:04:44 +0800 +0800'>九月 18, 2025</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;3380 字&nbsp;·&nbsp;cronrpc</div></header><figure class=entry-cover><img loading=eager srcset='https://cronrpc.github.io/zh/posts/deferred-rendering-path/cover_hu_43719b7b0afd9ce0.png 360w,https://cronrpc.github.io/zh/posts/deferred-rendering-path/cover_hu_88c12bee89a9c080.png 480w,https://cronrpc.github.io/zh/posts/deferred-rendering-path/cover_hu_22d86450b899ed05.png 720w,https://cronrpc.github.io/zh/posts/deferred-rendering-path/cover_hu_73a021080089bc5.png 1080w,https://cronrpc.github.io/zh/posts/deferred-rendering-path/cover_hu_f172524d8d770316.png 1500w,https://cronrpc.github.io/zh/posts/deferred-rendering-path/cover.png 1600w' src=https://cronrpc.github.io/zh/posts/deferred-rendering-path/cover.png sizes="(min-width: 768px) 720px, 100vw" width=1600 height=900 alt></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-unity-render-pipelines>1. Unity Render Pipelines</a><ul><li><a href=#11-unity-渲染管线的流程>1.1 Unity 渲染管线的流程</a></li><li><a href=#12-urp--hdrp--built-in>1.2 URP / HDRP / Built-in</a></li><li><a href=#13-render-target-和-mrt>1.3 Render Target 和 MRT</a></li></ul></li><li><a href=#2-render-path>2. Render Path</a><ul><li><a href=#21-forward-path>2.1 Forward Path</a></li><li><a href=#22-prepass--early-z>2.2 PrePass / Early-Z</a></li><li><a href=#23-deferred-path>2.3 Deferred Path</a></li><li><a href=#24-shadow-map>2.4 Shadow Map</a></li><li><a href=#25-半透明物体>2.5 半透明物体</a></li><li><a href=#26-在延迟渲染中使用前向渲染>2.6 在延迟渲染中使用前向渲染</a></li><li><a href=#27-forward-path>2.7 Forward+ Path</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=1-unity-render-pipelines>1. Unity Render Pipelines<a hidden class=anchor aria-hidden=true href=#1-unity-render-pipelines>#</a></h2><h3 id=11-unity-渲染管线的流程>1.1 Unity 渲染管线的流程<a hidden class=anchor aria-hidden=true href=#11-unity-渲染管线的流程>#</a></h3><p>渲染管线是引擎的渲染步骤，也就是游戏引擎把游戏对象转化为图像显示到屏幕上的步骤。</p><p>一个渲染管线大致可以分为下列几个步骤：</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/unity-render-pipeline.png></p><ul><li>剔除：包括视锥剔除和遮挡剔除（这里的遮挡剔除是指如果物体被另一个物体遮挡就直接剔除，但是通常是固定场景的遮挡进行这种剔除，比如进入房间之后遮挡其他房间，可参考<a href=https://docs.unity3d.com/Manual/OcclusionCulling.html>OcclusionCulling</a>。</li><li>渲染：绘制物体和它们的光照到相应的像素缓冲（pixel buffer）上。</li><li>后处理：修改像素缓冲为最后的输出结果。这一步可以做出一些效果，比如 bloom、景深等。</li></ul><p>有时候会把它和图形管线混淆，实际上 Graphics Pipeline 是指下面这个图（来自Vulkan）：</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/vulkan-graphics-pipeline.png></p><p>它是 GPU 中绘制图像的流程，首先变换顶点，然后光栅化，再进行片元着色。它实际上仅仅对应渲染管线中用到的一个功能，也就是 Rendering 这个步骤中的着色。如果你学习图形学知识，主要深入的是图形管线的编写。而 Unity 中我们不仅仅需要关注图形管线，还需要了解整个渲染管线。</p><hr><h3 id=12-urp--hdrp--built-in>1.2 URP / HDRP / Built-in<a hidden class=anchor aria-hidden=true href=#12-urp--hdrp--built-in>#</a></h3><p>官方有提供三种渲染管线：</p><ul><li>URP：属于可编程渲染管线（SRP，Scriptable Render Pipelines），适配不同平台的可扩展的图形。</li><li>HDRP：SRP，前沿的高保真的显示效果，通常用于高端设备。</li><li>Built-in：通用渲染管线，定制化程度相比 SRP 比较低。</li></ul><p>SRP 允许你通过编写 C# 代码来定制上面提到的剔除、渲染和后处理三个步骤，（Built-In 也可以定制修改不过你需要先获得源代码）。除了 URP 和 HDRP，你还可以编写自己的 SRP。</p><p>Built-in 是旧版的渲染管线，现在完全不需要去考虑这个，只有一些过去的项目开发者会选择这个。如果现在去学习一些教程，一些2022年以前写的书籍通常会使用这个，而新版的教程视频通常都是采用 URP。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/Unity-Render-Pipelines.png></p><hr><h3 id=13-render-target-和-mrt>1.3 Render Target 和 MRT<a hidden class=anchor aria-hidden=true href=#13-render-target-和-mrt>#</a></h3><p>渲染目标就是渲染结果输出的目标，可以理解为是一块画布，能够往上面写入任何东西。</p><p>渲染目标可以是多个，例如在前向渲染中，最基本的有3个，颜色（RGBA 4通道）、深度、模板（Stencil），当然深度和模板通常都不是4通道的，所以有可能会合并在一张画布上。</p><p>在正向渲染中通常只需要 2 个RT，颜色加 Depth，其中深度是可以配置精度的，比如24位或者32位，以及是否混合 Stencil。</p><p>GPU是可以同时输出多张 Render Target 的，这个特性在图形 API 里叫做 MRT（Multiple Render Targets，多渲染目标）。</p><p>在延迟渲染中，GBuffer同时输出了多个 RT。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/Render-Target.png></p><p>在一次几何遍历中输出了不同的信息用于后续的渲染，例如：</p><ul><li>RT0: 漫反射颜色 (Diffuse Color)</li><li>RT1: 法线 (Normal) 等</li><li>RT2: 镜面反射参数 (Specular, Roughness)</li><li>RT4: 自定义数据，比如材质ID等</li></ul><p>这就是延迟渲染 (Deferred Rendering) 使用 MRT 的原因，如果没有这个特性，需要写几个 Pass，每次 Pass 遍历只是为了获取一张 RT，那样效率就低了。</p><hr><h2 id=2-render-path>2. Render Path<a hidden class=anchor aria-hidden=true href=#2-render-path>#</a></h2><p>中文可以叫做渲染路径。</p><p>渲染路径是指绘制和照亮相机能看到的游戏对象的系列操作。不同的渲染路径具有不同的功能和性能特点。如果说渲染管线是做饭的一套流程，那么渲染路径可以理解为是放调味品的顺序和时机。比如计算光照的时机到底是在全局深度测试之前，还是全局深度测试之后等。</p><p>Unity支持两种方式：前向渲染（Forward）和延迟渲染（Deferred）以及它们的改进形式。</p><p>这里推荐阅读：毛星云关于延迟渲染的总结<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。</p><p>因为 URP 可以同时运行在各种平台上，包括手机，所以通常都是采用 URP 这个管线来开发 Unity 游戏。所以这里不对 HDRP 进行介绍，HDRP 有更多高级功能，支持光线追踪，如果想了解可以去查阅文档。</p><hr><h3 id=21-forward-path>2.1 Forward Path<a hidden class=anchor aria-hidden=true href=#21-forward-path>#</a></h3><p>正向渲染是一种传统的图形渲染管线方式。在这种模式下，每个物体都会依次经过顶点着色、光栅化、片元着色等阶段，并且在片元着色器（Fragment Shader）中会直接计算光照和材质效果。</p><p>正向渲染在处理物体的时候，会进行深度测试与着色，先渲染的物体有可能被后渲染的物体覆盖，因为后渲染的物体距离屏幕更近。</p><p>这样在最坏的情况下，所有物体都会经过着色，此时如果有 n 个物体，m 个光源，那么复杂度就是 $O(n * m)$。</p><hr><h3 id=22-prepass--early-z>2.2 PrePass / Early-Z<a hidden class=anchor aria-hidden=true href=#22-prepass--early-z>#</a></h3><p>注意，上面提到的是经典的正向渲染，没有考虑 prePass 来先遍历深度等方式。实际上现在的 URP 中的 Forward Path 是会先用 prePass 获取深度，这种情况下复杂度就不能说是 $O(n * m)$，而是 $O(n + m)$。这里的光源计算次数应该是分辨率乘以光照数，但是分辨率通常会认为是个常数。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/urp-prepass-depthnormal.png></p><p>前向渲染通过 prePass 方式来处理还是和延迟渲染有区别的，区别在于带宽和遍历次数，按照 prePass 方式有 2 次遍历，按照延迟渲染的方式没有 2 次遍历，不过需要多输出几张 RT。</p><p>还有一种叫做 Early-Z，是在对片元着色（光照计算）之前先进行深度测试，而不是计算之后再判断。现在的 GPU 普遍提供这个技术了。但是这个技术没有 prePass 彻底，它只是避免了近处物体计算后又计算远处物体，但是没有避免先计算远处物体导致的多余计算。</p><hr><h3 id=23-deferred-path>2.3 Deferred Path<a hidden class=anchor aria-hidden=true href=#23-deferred-path>#</a></h3><p>延迟渲染，对比经典的前向渲染，对于多光源的性能效果非常好。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/deferred-path-scene.png></p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/deferred-path-scene-game.png></p><p>延迟渲染首先遍历整个场景，进行一次绘制，但是它的输出不是光照后的结果，而是一些基本的信息，比如反照率、法线、高光度等等，输出几张 RT。在全部遍历完毕以后，再对所有像素进行一次遍历，根据 RT 对每个像素进行光照计算。</p><p>我们统称这些 RT 为 GBuffer，实际上就是一个个像素的信息。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/GBuffer.png></p><p>这么来看，延迟渲染就是单纯把光照计算这个部分拿出来了，法线采样、贴图采用次数什么的都没有减少，只是都存起来。</p><p>而前向渲染如果单独把深度测试提取出来，那么整个其实最后计算的光照数量应该和延迟是一样的。但是这样就少用一些图去存储GBuffer，但同时也会多一些遍历次数。</p><p>因为延迟渲染GBuffer生成之后只要遍历pixel，但是如果是深度测试单独提取出来，依然还是需要遍历一次所有物体。</p><p>从下图可以看到，延迟渲染首先渲染了 GBuffer，之后在 Deferred Pass 中进行光照计算，光照计算也是通过多次着色来实现的，每多一个光照就需要多进行一些绘制。</p><p>可以看到，图中处理的方式是，对于每个光源，遍历一次受影响的像素，来进行针对该光源的颜色绘制，这样一个光源一个光源地添加颜色。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/deferred-Pass.png></p><p>延迟渲染还是要考虑多材质这个问题，例如，上图的地面和方块就不是一个材质。</p><p>解决方法有 2 种，URP 中默认的方式是在 GBuffer 阶段通过 Stencil 标记材质。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/Stencil-ref-GBuffer.png></p><p>然后在 Deferred Pass 阶段根据 Stencil 来走不同的 Pass 进行绘制。当然你会看到 Stencil Ref 有点差异是因为还有一个上色的过程，这里有一个 Bit 用来标记是否需要上色（是否被某个光照到）。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/Stencil-ref-Deferred-Pass.png></p><p>另一个方式就是不需要这么多的 Pass，通过在 GBuffer 中使用某些比特位来标记材质，这样在同一个 Pass 中走不同的分支就可以代表不同材质了。</p><hr><h3 id=24-shadow-map>2.4 Shadow Map<a hidden class=anchor aria-hidden=true href=#24-shadow-map>#</a></h3><p>这么多光源，会不会影响性能？除了前面的地 Deferred Pass，阴影部分也是影响性能的地方。</p><p>前面讨论的延迟渲染中，光源是没有阴影的，所以我们只感觉添加一个光就是添加了 一点 Deferred Pass。</p><p>但是如果是下图这种聚光灯效果：</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/shadow-spot-scene.png></p><p>可以直接穿透物体照射后面的物体。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/shadow-spot-light.png></p><p>原因是我们没有开启光源的阴影，需要在光源的设置中开启它。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/shadow-setting.png></p><p>开启之后，光源就会通过 Shadow Map 技术，来生产光源的 Shadow Map，1个点光源通常生成 6 张图，涵盖 6 个方向。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/shadow-map-cube.png></p><p>这时就产生了遮挡关系。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/shadow-final-shadow.png></p><hr><h3 id=25-半透明物体>2.5 半透明物体<a hidden class=anchor aria-hidden=true href=#25-半透明物体>#</a></h3><p>延迟渲染中如何渲染半透明物体？答案是在延迟渲染完不透明物体之后，再用前向渲染的方式渲染半透明物体。</p><hr><h3 id=26-在延迟渲染中使用前向渲染>2.6 在延迟渲染中使用前向渲染<a hidden class=anchor aria-hidden=true href=#26-在延迟渲染中使用前向渲染>#</a></h3><p>如何在延迟渲染中增加一个前向渲染？</p><p>可以通过增加 Render Objects 这样一个 Renderer Features，在某个事件后插入。比如这里选择在渲染透明物体之前渲染。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/forward-in-deferred-setting.png></p><p>当延迟渲染完毕后，还没有渲染物体。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/forward-in-deferred-pass.png></p><p>插入了一个渲染物体的 Pass。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/forward-in-deferred-after-forward-render.png></p><p>不用担心光照遮挡问题，因为光照可以设置影响的 Layer，设置正确的话遮挡关系也是会正确的。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/forward-in-deferred-light-setting.png></p><p>关于插入的位置，基本上 Opaques 之后都是可以的，因为参考<a href=https://docs.unity3d.com/6000.2/Documentation/Manual/urp/rendering/render-passes-deferred.html>Render event</a>，Deferred Pass 发生在 BeforeRenderingOpaques 之前。</p><hr><h3 id=27-forward-path>2.7 Forward+ Path<a hidden class=anchor aria-hidden=true href=#27-forward-path>#</a></h3><p>前向+渲染路径与标准的前向渲染路径类似，但没有限制每个游戏对象可以受多少个光源影响。不过，每台摄像机可见光源的数量仍然有限制。</p><p>使用前向+渲染路径减少了Unity为每个游戏对象计算的光源数量。Unity将屏幕划分为多个瓦片，然后确定哪些光源会影响这些瓦片。当Unity计算某个游戏对象的光照时，它只会使用影响该游戏对象所在瓦片的光源。</p><p><img alt="alt text" loading=lazy src=/zh/posts/deferred-rendering-path/unity-forward-path-plus.png></p><p>每个网格方块是一个瓦片，每个值表示影响该瓦片的灯光数量。</p><p>Unity 在选择 Forward+ 渲染路径时会忽略以下设置：</p><ul><li>URP 资源中的附加灯光。</li><li>URP 资源中的主灯光。</li><li>URP 资源中附加灯光 > 每个对象限制。</li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>毛星云, 【《Real-Time Rendering 3rd》 提炼总结】(七) 第七章续 · 延迟渲染(Deferred Rendering)的前生今世, <a href=https://zhuanlan.zhihu.com/p/28489928>https://zhuanlan.zhihu.com/p/28489928</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://cronrpc.github.io/zh/tags/unity/>Unity</a></li><li><a href=https://cronrpc.github.io/zh/tags/deferred-rendering/>Deferred Rendering</a></li></ul><nav class=paginav><a class=next href=https://cronrpc.github.io/zh/posts/unity-input-system/><span class=title>下一页 »</span><br><span>Unity Input System</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Deferred Rendering Path on x" href="https://x.com/intent/tweet/?text=Deferred%20Rendering%20Path&amp;url=https%3a%2f%2fcronrpc.github.io%2fzh%2fposts%2fdeferred-rendering-path%2f&amp;hashtags=Unity%2cDeferredRendering"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Deferred Rendering Path on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcronrpc.github.io%2fzh%2fposts%2fdeferred-rendering-path%2f&amp;title=Deferred%20Rendering%20Path&amp;summary=Deferred%20Rendering%20Path&amp;source=https%3a%2f%2fcronrpc.github.io%2fzh%2fposts%2fdeferred-rendering-path%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Deferred Rendering Path on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcronrpc.github.io%2fzh%2fposts%2fdeferred-rendering-path%2f&title=Deferred%20Rendering%20Path"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Deferred Rendering Path on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcronrpc.github.io%2fzh%2fposts%2fdeferred-rendering-path%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Deferred Rendering Path on whatsapp" href="https://api.whatsapp.com/send?text=Deferred%20Rendering%20Path%20-%20https%3a%2f%2fcronrpc.github.io%2fzh%2fposts%2fdeferred-rendering-path%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Deferred Rendering Path on telegram" href="https://telegram.me/share/url?text=Deferred%20Rendering%20Path&amp;url=https%3a%2f%2fcronrpc.github.io%2fzh%2fposts%2fdeferred-rendering-path%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Deferred Rendering Path on ycombinator" href="https://news.ycombinator.com/submitlink?t=Deferred%20Rendering%20Path&u=https%3a%2f%2fcronrpc.github.io%2fzh%2fposts%2fdeferred-rendering-path%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://cronrpc.github.io/zh/>cronrpc 中文</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>