[{"content":"1. Unity Render Pipelines 1.1 Unity 渲染管线的流程 渲染管线是引擎的渲染步骤，也就是游戏引擎把游戏对象转化为图像显示到屏幕上的步骤。\n一个渲染管线大致可以分为下列几个步骤：\n剔除：包括视锥剔除和遮挡剔除（这里的遮挡剔除是指如果物体被另一个物体遮挡就直接剔除，但是通常是固定场景的遮挡进行这种剔除，比如进入房间之后遮挡其他房间，可参考OcclusionCulling。 渲染：绘制物体和它们的光照到相应的像素缓冲（pixel buffer）上。 后处理：修改像素缓冲为最后的输出结果。这一步可以做出一些效果，比如 bloom、景深等。 有时候会把它和图形管线混淆，实际上 Graphics Pipeline 是指下面这个图（来自Vulkan）：\n它是 GPU 中绘制图像的流程，首先变换顶点，然后光栅化，再进行片元着色。它实际上仅仅对应渲染管线中用到的一个功能，也就是 Rendering 这个步骤中的着色。如果你学习图形学知识，主要深入的是图形管线的编写。而 Unity 中我们不仅仅需要关注图形管线，还需要了解整个渲染管线。\n1.2 URP / HDRP / Built-in 官方有提供三种渲染管线：\nURP：属于可编程渲染管线（SRP，Scriptable Render Pipelines），适配不同平台的可扩展的图形。 HDRP：SRP，前沿的高保真的显示效果，通常用于高端设备。 Built-in：通用渲染管线，定制化程度相比 SRP 比较低。 SRP 允许你通过编写 C# 代码来定制上面提到的剔除、渲染和后处理三个步骤，（Built-In 也可以定制修改不过你需要先获得源代码）。除了 URP 和 HDRP，你还可以编写自己的 SRP。\nBuilt-in 是旧版的渲染管线，现在完全不需要去考虑这个，只有一些过去的项目开发者会选择这个。如果现在去学习一些教程，一些2022年以前写的书籍通常会使用这个，而新版的教程视频通常都是采用 URP。\n1.3 Render Target 和 MRT 渲染目标就是渲染结果输出的目标，可以理解为是一块画布，能够往上面写入任何东西。\n渲染目标可以是多个，例如在前向渲染中，最基本的有3个，颜色（RGBA 4通道）、深度、模板（Stencil），当然深度和模板通常都不是4通道的，所以有可能会合并在一张画布上。\n在正向渲染中通常只需要 2 个RT，颜色加 Depth，其中深度是可以配置精度的，比如24位或者32位，以及是否混合 Stencil。\nGPU是可以同时输出多张 Render Target 的，这个特性在图形 API 里叫做 MRT（Multiple Render Targets，多渲染目标）。\n在延迟渲染中，GBuffer同时输出了多个 RT。\n在一次几何遍历中输出了不同的信息用于后续的渲染，例如：\nRT0: 漫反射颜色 (Diffuse Color) RT1: 法线 (Normal) 等 RT2: 镜面反射参数 (Specular, Roughness) RT4: 自定义数据，比如材质ID等 这就是延迟渲染 (Deferred Rendering) 使用 MRT 的原因，如果没有这个特性，需要写几个 Pass，每次 Pass 遍历只是为了获取一张 RT，那样效率就低了。\n2. Render Path 中文可以叫做渲染路径。\n渲染路径是指绘制和照亮相机能看到的游戏对象的系列操作。不同的渲染路径具有不同的功能和性能特点。如果说渲染管线是做饭的一套流程，那么渲染路径可以理解为是放调味品的顺序和时机。比如计算光照的时机到底是在全局深度测试之前，还是全局深度测试之后等。\nUnity支持两种方式：前向渲染（Forward）和延迟渲染（Deferred）以及它们的改进形式。\n这里推荐阅读：毛星云关于延迟渲染的总结1。\n因为 URP 可以同时运行在各种平台上，包括手机，所以通常都是采用 URP 这个管线来开发 Unity 游戏。所以这里不对 HDRP 进行介绍，HDRP 有更多高级功能，支持光线追踪，如果想了解可以去查阅文档。\n2.1 Forward Path 正向渲染是一种传统的图形渲染管线方式。在这种模式下，每个物体都会依次经过顶点着色、光栅化、片元着色等阶段，并且在片元着色器（Fragment Shader）中会直接计算光照和材质效果。\n正向渲染在处理物体的时候，会进行深度测试与着色，先渲染的物体有可能被后渲染的物体覆盖，因为后渲染的物体距离屏幕更近。\n这样在最坏的情况下，所有物体都会经过着色，此时如果有 n 个物体，m 个光源，那么复杂度就是 $O(n * m)$。\n2.2 PrePass / Early-Z 注意，上面提到的是经典的正向渲染，没有考虑 prePass 来先遍历深度等方式。实际上现在的 URP 中的 Forward Path 是会先用 prePass 获取深度，这种情况下复杂度就不能说是 $O(n * m)$，而是 $O(n + m)$。这里的光源计算次数应该是分辨率乘以光照数，但是分辨率通常会认为是个常数。\n前向渲染通过 prePass 方式来处理还是和延迟渲染有区别的，区别在于带宽和遍历次数，按照 prePass 方式有 2 次遍历，按照延迟渲染的方式没有 2 次遍历，不过需要多输出几张 RT。\n还有一种叫做 Early-Z，是在对片元着色（光照计算）之前先进行深度测试，而不是计算之后再判断。现在的 GPU 普遍提供这个技术了。但是这个技术没有 prePass 彻底，它只是避免了近处物体计算后又计算远处物体，但是没有避免先计算远处物体导致的多余计算。\n2.3 Deferred Path 延迟渲染，对比经典的前向渲染，对于多光源的性能效果非常好。\n延迟渲染首先遍历整个场景，进行一次绘制，但是它的输出不是光照后的结果，而是一些基本的信息，比如反照率、法线、高光度等等，输出几张 RT。在全部遍历完毕以后，再对所有像素进行一次遍历，根据 RT 对每个像素进行光照计算。\n我们统称这些 RT 为 GBuffer，实际上就是一个个像素的信息。\n这么来看，延迟渲染就是单纯把光照计算这个部分拿出来了，法线采样、贴图采用次数什么的都没有减少，只是都存起来。\n而前向渲染如果单独把深度测试提取出来，那么整个其实最后计算的光照数量应该和延迟是一样的。但是这样就少用一些图去存储GBuffer，但同时也会多一些遍历次数。\n因为延迟渲染GBuffer生成之后只要遍历pixel，但是如果是深度测试单独提取出来，依然还是需要遍历一次所有物体。\n从下图可以看到，延迟渲染首先渲染了 GBuffer，之后在 Deferred Pass 中进行光照计算，光照计算也是通过多次着色来实现的，每多一个光照就需要多进行一些绘制。\n可以看到，图中处理的方式是，对于每个光源，遍历一次受影响的像素，来进行针对该光源的颜色绘制，这样一个光源一个光源地添加颜色。\n延迟渲染还是要考虑多材质这个问题，例如，上图的地面和方块就不是一个材质。\n解决方法有 2 种，URP 中默认的方式是在 GBuffer 阶段通过 Stencil 标记材质。\n然后在 Deferred Pass 阶段根据 Stencil 来走不同的 Pass 进行绘制。当然你会看到 Stencil Ref 有点差异是因为还有一个上色的过程，这里有一个 Bit 用来标记是否需要上色（是否被某个光照到）。\n另一个方式就是不需要这么多的 Pass，通过在 GBuffer 中使用某些比特位来标记材质，这样在同一个 Pass 中走不同的分支就可以代表不同材质了。\n2.4 Shadow Map 这么多光源，会不会影响性能？除了前面的地 Deferred Pass，阴影部分也是影响性能的地方。\n前面讨论的延迟渲染中，光源是没有阴影的，所以我们只感觉添加一个光就是添加了 一点 Deferred Pass。\n但是如果是下图这种聚光灯效果：\n可以直接穿透物体照射后面的物体。\n原因是我们没有开启光源的阴影，需要在光源的设置中开启它。\n开启之后，光源就会通过 Shadow Map 技术，来生产光源的 Shadow Map，1个点光源通常生成 6 张图，涵盖 6 个方向。\n这时就产生了遮挡关系。\n2.5 半透明物体 延迟渲染中如何渲染半透明物体？答案是在延迟渲染完不透明物体之后，再用前向渲染的方式渲染半透明物体。\n2.6 在延迟渲染中使用前向渲染 如何在延迟渲染中增加一个前向渲染？\n可以通过增加 Render Objects 这样一个 Renderer Features，在某个事件后插入。比如这里选择在渲染透明物体之前渲染。\n当延迟渲染完毕后，还没有渲染物体。\n插入了一个渲染物体的 Pass。\n不用担心光照遮挡问题，因为光照可以设置影响的 Layer，设置正确的话遮挡关系也是会正确的。\n关于插入的位置，基本上 Opaques 之后都是可以的，因为参考Render event，Deferred Pass 发生在 BeforeRenderingOpaques 之前。\n2.7 Forward+ Path 前向+渲染路径与标准的前向渲染路径类似，但没有限制每个游戏对象可以受多少个光源影响。不过，每台摄像机可见光源的数量仍然有限制。\n使用前向+渲染路径减少了Unity为每个游戏对象计算的光源数量。Unity将屏幕划分为多个瓦片，然后确定哪些光源会影响这些瓦片。当Unity计算某个游戏对象的光照时，它只会使用影响该游戏对象所在瓦片的光源。\n每个网格方块是一个瓦片，每个值表示影响该瓦片的灯光数量。\nUnity 在选择 Forward+ 渲染路径时会忽略以下设置：\nURP 资源中的附加灯光。 URP 资源中的主灯光。 URP 资源中附加灯光 \u0026gt; 每个对象限制。 毛星云, 【《Real-Time Rendering 3rd》 提炼总结】(七) 第七章续 · 延迟渲染(Deferred Rendering)的前生今世, https://zhuanlan.zhihu.com/p/28489928\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://cronrpc.github.io/zh/posts/deferred-rendering-path/","summary":"\u003ch2 id=\"1-unity-render-pipelines\"\u003e1. Unity Render Pipelines\u003c/h2\u003e\n\u003ch3 id=\"11-unity-渲染管线的流程\"\u003e1.1 Unity 渲染管线的流程\u003c/h3\u003e\n\u003cp\u003e渲染管线是引擎的渲染步骤，也就是游戏引擎把游戏对象转化为图像显示到屏幕上的步骤。\u003c/p\u003e\n\u003cp\u003e一个渲染管线大致可以分为下列几个步骤：\u003c/p\u003e","title":"Deferred Rendering Path"},{"content":"一个系统的输入有哪些？\n如果是电脑上，有鼠标、键盘、手柄；主机上主要是手柄；移动设备上则是屏幕、加速度计、陀螺仪。\n除此之外，还有一些比较特殊的反馈，例如PC手柄的基础振动，PS平台的手柄还支持力反馈和吹气，移动端也可以触发手机的振动等。\n1. Input Manager 在开始介绍 Input System 之前，稍微回顾下之前的输入系统 Input Manager。\n首先，输入系统肯定需要支持读取较为原始的输入，比如一个具体的键盘按键是否被按下，鼠标在屏幕上的位置，两帧之间的鼠标移动的差值等等。\n同时，作为一个系统，它应该也需要提供一点抽象。Input Manager 提供了两种抽象，一种是按键（Button），一种是轴向（Axis），在本文后面会提到。\n1.1 检测键盘鼠标的输入 一个系统最基本的功能就是要能比较原始的去检测键盘鼠标的输入，Input Manager 采用的是轮询机制，也就是说，程序员在每次 Update 中去主动去轮询是否有按键按下。\n下面是一个在 Update 中轮询检测键盘和鼠标：\nvoid Update() { // 按下一次触发（帧级检测） if (Input.GetKeyDown(KeyCode.Space)) { Debug.Log(\u0026#34;按下了空格键\u0026#34;); } // 按住时持续触发 if (Input.GetKey(KeyCode.W)) { Debug.Log(\u0026#34;正在按住 W 键\u0026#34;); } // 松开时触发 if (Input.GetKeyUp(KeyCode.Escape)) { Debug.Log(\u0026#34;松开了 Esc 键\u0026#34;); } // 检测鼠标位置 Vector3 mousePos = Input.mousePosition; // 左键按下 if (Input.GetMouseButtonDown(0)) { Debug.Log(\u0026#34;Left Click at \u0026#34; + mousePos); } } 有了鼠标和键盘的基本输入就完全够了，现在只要不断配合其他API，加上一些代码上的组织，就可以实现任何 PC 游戏上的任何功能。\n例如在游戏中，想检测鼠标点击的物体，可以用射线投射：\nif (Input.GetMouseButtonDown(0)) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, out RaycastHit hit)) { Debug.Log(\u0026#34;Clicked on \u0026#34; + hit.collider.name); } } 1.2 按键和轴 在 Edit → Project Settings → Input Manager 中，Unity 默认已经配置了一些输入（比如 Fire1、Jump）。\n对于每个输入，可以采用按键方式或者轴的方式去读取，这里相当于做了一层简单的抽象。并且多个来源的输入，是可以绑定为同一个 Name 的，这样就支持了多设备输入。\n实现按键的读取，只需要用 GetButtonDown 的 API 去读取设置中定义的 Name：\n// Fire1 默认绑定是 Ctrl / 鼠标左键 / 手柄 A 键 if (Input.GetButtonDown(\u0026#34;Fire1\u0026#34;)) { Debug.Log(\u0026#34;执行攻击！\u0026#34;); } // Jump 默认绑定是空格键 if (Input.GetButtonDown(\u0026#34;Jump\u0026#34;)) { Debug.Log(\u0026#34;跳跃\u0026#34;); } 同样，也可以使用 GetAxis 去读取 Name 实现一个WASD的操作，能作为一个轴来读取的需要设置正值表示的按键和负值表示的按键，或者绑定到一个摇杆轴上：\n// 键盘 A/D 或 左/右箭头，默认映射为 Horizontal float horizontal = Input.GetAxis(\u0026#34;Horizontal\u0026#34;); // 键盘 W/S 或 上/下箭头，默认映射为 Vertical float vertical = Input.GetAxis(\u0026#34;Vertical\u0026#34;); Vector3 move = new Vector3(horizontal, 0, vertical); Debug.Log(\u0026#34;当前输入方向：\u0026#34; + move); 1.3 手机传感器 移动端和 PC 端的差异还是非常大的，通常手机上是没有键盘设备的，只有手指能代替鼠标进行一些点击，所以移动端设备会使用虚拟摇杆和一些虚拟按钮，比如王者荣耀、PUBG。\n除了操作虚拟摇杆和虚拟按钮，还有一些传感器是 PC 上没有的，比如陀螺仪。\n加速度\nVector3 accel = Input.acceleration; Debug.Log(\u0026#34;加速度: \u0026#34; + accel); 陀螺仪\nInput.gyro.enabled = true; // 设备方向 Quaternion attitude = Input.gyro.attitude; // 重力方向 Vector3 gravity = Input.gyro.gravity; // 角速度 Vector3 rotationRate = Input.gyro.rotationRate; 指南针\nInput.compass.enabled = true; float heading = Input.compass.trueHeading; Debug.Log(\u0026#34;朝向角度: \u0026#34; + heading); 设备方向\nif (Input.deviceOrientation == DeviceOrientation.LandscapeLeft) { Debug.Log(\u0026#34;横屏（左）\u0026#34;); } 触控屏这个使用起来的时候会稍微复杂一点，建议阅读下官方文档：Unity-TouchPhase\nInput API 可以查看有多少个手指触摸屏幕，以及每个手指是点击还是移动等。你可以想象是有很多个鼠标放在手机屏幕上，当然差别在于还可以通过半径来检测触摸半径（部分设备支持）。\nif (Input.touchCount \u0026gt; 0) { Touch touch = Input.GetTouch(0); Debug.Log($\u0026#34;触摸位置: {touch.position}, 半径: {touch.radius}, 压力: {touch.pressure}\u0026#34;); if (touch.phase == TouchPhase.Moved) { // 把屏幕移动量转成世界坐标偏移 Vector3 delta = new Vector3(touch.deltaPosition.x, touch.deltaPosition.y, 0); transform.Translate(delta * 0.01f); } } 1.4 局限性 虽然理论上大部分功能都可以通过 Input Manager 实现，但是有一些局限性依然存在。现在 Unity 官方已经推荐完全使用 Input System 系统，也推荐在项目打包的时候，仅仅保留 Input System。\n有几个比较明显的局限性：\n绑定是固定的，运行时无法修改：所有输入映射都在 Project Settings → Input Manager 里配置。 游戏运行中不能动态改键，玩家无法自由设置按键。如果要做改键功能，只能自己写一层封装。 不支持新的硬件：VR/AR、Switch JoyCon、PS5 自适应扳机等。 不支持热插拔。插入或拔出新设备（如手柄），游戏中不会自动识别。 Input System 完全是 Input Manager 的上位替代，建议开发的时候统一就用 Input System，这里写出 Input Manager 只是为了方便阅读一些老代码。\n2. Input System 2.1 切换输入系统 如果你使用的是 Unity 6 以上的版本，它默认就是同时开启 Input System 和 Input Manager 两种模式。\n在项目设置的 Player 中，可以找到当前激活的输入系统，这里建议仅保留 Input System 即可。\n选择后需要重启编辑器才能生效。\n2.2 基本的输入 直接查询设备的状态，类似旧的 Input.GetKey。\nusing UnityEngine; using UnityEngine.InputSystem; public class DirectInputExample : MonoBehaviour { void Update() { if (Keyboard.current.spaceKey.wasPressedThisFrame) Debug.Log(\u0026#34;Space pressed!\u0026#34;); if (Mouse.current.leftButton.isPressed) Debug.Log(\u0026#34;Mouse Left Down\u0026#34;); if (Gamepad.current != null \u0026amp;\u0026amp; Gamepad.current.aButton.wasReleasedThisFrame) Debug.Log(\u0026#34;Gamepad A released\u0026#34;); } } 还有更底层的直接读取 event 信息的方法，直接注册到输入事件流，但是通常不会用到：\nusing UnityEngine; using UnityEngine.InputSystem; using UnityEngine.InputSystem.LowLevel; public class RawEventExample : MonoBehaviour { void OnEnable() { InputSystem.onEvent += OnInputEvent; } void OnDisable() { InputSystem.onEvent -= OnInputEvent; } void OnInputEvent(InputEventPtr eventPtr, InputDevice device) { Debug.Log($\u0026#34;Raw Event: {eventPtr.type}, Device: {device}\u0026#34;); } } 2.3 Input Action Asset 在资产窗口中右键点击 Create -\u0026gt; Input Action 可以创建一个 Input Action Asset。\n我们以 Unity 6 URP 项目默认的 Input Action Asset 为例来讲解一下配置：\nAction Maps：表示一组动作，类似控制模式，比如在游戏中可以是 Player，在 UI 界面则切换为 UI。同一时间只激活一组 Action Maps。 Actions：具体的操作，右侧可以选择 Action Type，有数值 Value，按钮 Button，还有 Pass Through 直通模式。一个 Actions 可以对应多种输入，比如 Move 就同时对应： 手柄左摇杆 (WASD/上下左右方向键) 摇杆类设备 2.4 使用 Player Input 组件 Player Input 组件是最简单的使用 Action 的方法，它支持选择 Map 和通知方式。\n通知方式有四种选择：\nSend Messages 和 Broadcast Messages Send Messages 和 Broadcast Messages 都是 Unity 中反射的方法，可以在对象之间进行通信。\n两种使用方式是一样的，只是 Send Messages 只会通知当前 gameObject ，而 Broadcast Messages 还会通知子对象。\n按照组件中提示的这些创建一个个方法，就可以接收消息了。由于只会在值改变的时候发送通知消息，所以 OnMove 的值需要保存下来。而 OnJump 只需要改变垂直速度一次就可以直接处理逻辑。\nusing UnityEngine; using UnityEngine.InputSystem; public class PlayerMovement : MonoBehaviour { [SerializeField] private float speed = 20; [SerializeField] private float jumpForce = 5; private Vector2 direction; void OnJump(InputValue value) { if (value.isPressed) { GetComponent\u0026lt;Rigidbody\u0026gt;().linearVelocity = new Vector3(0, jumpForce, 0); } } void OnMove(InputValue value) { direction = value.Get\u0026lt;Vector2\u0026gt;(); } private void Update() { transform.Translate(new Vector3(direction.x, 0, direction.y) * (Time.deltaTime * speed)); } } 测试下基本的移动和跳跃：\nC Sharp Events 用 C# 的事件机制来调用，这种方法更清晰的区分 started/canceled/performed 这三个时机。\n唯一需要注意的是，取消的时候记得取消注册通知，尤其是在不同关卡之间切换的时候，如果绑定了又忘记取消可能就会有 BUG 。\nusing System; using UnityEngine; using UnityEngine.InputSystem; public class PlayerMovementCSharpEvents : MonoBehaviour { [SerializeField] private float speed = 20; [SerializeField] private float jumpForce = 5; private Vector2 direction; private InputAction moveAction; private InputAction jumpAction; private void Start() { PlayerInput playerInput = GetComponent\u0026lt;PlayerInput\u0026gt;(); moveAction = playerInput.actions[\u0026#34;Move\u0026#34;]; jumpAction = playerInput.actions[\u0026#34;Jump\u0026#34;]; moveAction.performed += OnMovePerformed; moveAction.canceled += OnMoveCanceled; jumpAction.started += OnJumpStarted; } void OnDestroy() { moveAction.performed -= OnMovePerformed; moveAction.canceled -= OnMoveCanceled; jumpAction.started -= OnJumpStarted; } private void OnJumpStarted(InputAction.CallbackContext obj) { GetComponent\u0026lt;Rigidbody\u0026gt;().linearVelocity = new Vector3(0, jumpForce, 0); } private void OnMoveCanceled(InputAction.CallbackContext obj) { direction = Vector2.zero; } private void OnMovePerformed(InputAction.CallbackContext obj) { direction = obj.ReadValue\u0026lt;Vector2\u0026gt;(); } private void Update() { transform.Translate(new Vector3(direction.x, 0, direction.y) * (Time.deltaTime * speed)); } } Unity Events Unity Events 属于可视化拖动式绑定，只需要把一个个被调用的函数给写好：\nusing UnityEngine; using UnityEngine.InputSystem; public class PlayerMovementUnityEvents : MonoBehaviour { [SerializeField] private float speed = 20; [SerializeField] private float jumpForce = 5; private Vector2 direction; public void Jump(InputAction.CallbackContext action) { if (action.started) { GetComponent\u0026lt;Rigidbody\u0026gt;().linearVelocity = new Vector3(0, jumpForce, 0); } } public void Move(InputAction.CallbackContext action) { direction = action.ReadValue\u0026lt;Vector2\u0026gt;(); } private void Update() { transform.Translate(new Vector3(direction.x, 0, direction.y) * (Time.deltaTime * speed)); } } 然后在组件检视窗口中绑定相关的方法即可：\n2.5 Generate C# Class 最合适的用法还是完全通过代码来控制输入，前面使用组件的时候，解耦性过于强，只有运行过程中才能确定是否绑定成功。而通过生成代码的方式可以避免这个问题。\n首先找到 Input Action Asset，然后勾选生成代码 Generate C# Class，这里的类名可以指定一个新的。\n生成之后，最大的优势在于，之前需要通过字符串来表示的 Jump 现在都在编译期确定了，例如下面的：\nusing UnityEngine; public class PlayerController : MonoBehaviour { private InputSystem_Actions inputActions; private void Awake() { inputActions = new InputSystem_Actions(); } private void OnEnable() { inputActions.Enable(); } private void OnDisable() { inputActions.Disable(); } private void Update() { Vector2 move = inputActions.Player.Move.ReadValue\u0026lt;Vector2\u0026gt;(); if (inputActions.Player.Jump.triggered) { Debug.Log(\u0026#34;Jump pressed!\u0026#34;); } } } 2.6 Generate C# Class 和 事件 通常不推荐在 Update 中去轮询的做法，更好的做法是采用事件的机制，当某个按钮对应的事件发生的时候，去调用一个指定的函数。\n然后 new InputSystem_Actions() 多次也是不会有冲突的，它们都能够正常在不同组件中独立使用。不过通常我们还是会使用一个组件来获取所有的输入，然后通过事件机制传递给其他部分，而不是每个部分都单独创建一个新的 InputSystem_Actions。\nusing UnityEngine; using UnityEngine.InputSystem; public class PlayerController : MonoBehaviour { private InputSystem_Actions inputActions; [SerializeField] private float speed = 20; [SerializeField] private float jumpForce = 5; private Vector2 direction; private void Awake() { inputActions = new InputSystem_Actions(); } private void OnEnable() { inputActions.Player.Jump.started += OnJumpStarted; inputActions.Player.Move.performed += OnMovePerformed; inputActions.Player.Move.canceled += OnMoveCanceled; inputActions.Enable(); } private void OnDisable() { inputActions.Player.Jump.started -= OnJumpStarted; inputActions.Player.Move.performed -= OnMovePerformed; inputActions.Player.Move.canceled -= OnMoveCanceled; inputActions.Disable(); } private void OnJumpStarted(InputAction.CallbackContext ctx) { GetComponent\u0026lt;Rigidbody\u0026gt;().linearVelocity = new Vector3(0, jumpForce, 0); } private void OnMovePerformed(InputAction.CallbackContext ctx) { direction = ctx.ReadValue\u0026lt;Vector2\u0026gt;(); } private void OnMoveCanceled(InputAction.CallbackContext ctx) { direction = Vector2.zero; } private void Update() { transform.Translate(new Vector3(direction.x, 0, direction.y) * (Time.deltaTime * speed)); } } 3. 补充 3.1 手柄振动 我手上有一个 XBOX 的手柄，它支持设置低频振动和高频振动。低频振动会有更大的抖动感，高频更像是手机振动的那种提醒感。\n振动通过 Gamepad 来设置，例如下面的代码中，按下 A 键触发振动，按下 X 键停止振动。这里停止就是指设置振动值为 0 。\nusing UnityEngine; using UnityEngine.InputSystem; public class GamepadHaptics : MonoBehaviour { private Gamepad gamepad; private void Update() { gamepad = Gamepad.current; if (gamepad == null) return; if (gamepad.buttonSouth.wasPressedThisFrame) { // 设置低频和高频振动（0~1） gamepad.SetMotorSpeeds(0.5f, 0.5f); } if (gamepad.buttonWest.wasPressedThisFrame) { gamepad?.SetMotorSpeeds(0f, 0f); } } } 3.2 陀螺仪等 和旧版的输入系统一样，Input System 也能读取移动设备（手机、平板）的陀螺仪和加速度计。\nusing UnityEngine; using UnityEngine.InputSystem; public class MobileSensors : MonoBehaviour { private void Update() { // 加速度 Vector3 accel = Accelerometer.current?.acceleration.ReadValue() ?? Vector3.zero; Debug.Log($\u0026#34;Acceleration: {accel}\u0026#34;); // 陀螺仪 if (Gyroscope.current != null) { Vector3 gyro = Gyroscope.current.angularVelocity.ReadValue(); Debug.Log($\u0026#34;Gyro: {gyro}\u0026#34;); } } } 3.3 虚拟摇杆 商店中有一些可用的资源：Joystick Pack\n这里讲解一个简单的不依赖外部实现的方式：\n首先创建一个 UI 界面，然后创建：\nImage 虚拟摇杆背景 JoystickBG Image 虚拟摇杆 JoystickHandle，放在背景 JoystickBG 的正中间 然后给虚拟摇杆 JoystickHandle 上一个组件 Event Trigger，它在按下、拖拽、抬起的时候，都会发送事件。\n之后 MobileController 的代码如下：\n通过绑定事件来触发摇杆的效果 using System; using UnityEngine; using UnityEngine.EventSystems; public class MobileController : MonoBehaviour { [Header(\u0026#34;UI Elements\u0026#34;)] public RectTransform joystickBG; public RectTransform joystickHandle; [Header(\u0026#34;Settings\u0026#34;)] public float joystickMaxRange = 100f; // 摇杆最大位移 private Vector2 joystickInput = Vector2.zero; public event Action\u0026lt;Vector2\u0026gt; OnPerformed; private void Update() { // 通知 Debug.Log($\u0026#34;Joystick Input: {joystickInput}\u0026#34;); OnPerformed?.Invoke(joystickInput); } public void OnJoystickDrag(BaseEventData data) { PointerEventData pointerData = data as PointerEventData; Vector2 pos; RectTransformUtility.ScreenPointToLocalPointInRectangle( joystickBG, pointerData.position, pointerData.pressEventCamera, out pos ); // 限制最大范围 joystickInput = Vector2.ClampMagnitude(pos / joystickMaxRange, 1f); // 更新手柄位置（UI效果） joystickHandle.anchoredPosition = joystickInput * joystickMaxRange; } public void OnJoystickEndDrag(BaseEventData data) { joystickInput = Vector2.zero; joystickHandle.anchoredPosition = Vector2.zero; Debug.Log(\u0026#34;Joystick Released\u0026#34;); } } 使用的时候只要注册到这个 OnPerformed 事件就可以了：\nusing UnityEngine; public class PlayerController : MonoBehaviour { [SerializeField] MobileController mobileController; [SerializeField] private float speed = 20; [SerializeField] private float jumpForce = 5; private Vector2 direction; private void OnEnable() { mobileController.OnPerformed += MobileControllerOnOnPerformed; } private void MobileControllerOnOnPerformed(Vector2 mobileInput) { direction = mobileInput; } private void Update() { transform.Translate(new Vector3(direction.x, 0, direction.y) * (Time.deltaTime * speed)); } } 看一下演示效果：\n","permalink":"https://cronrpc.github.io/zh/posts/unity-input-system/","summary":"\u003cp\u003e一个系统的输入有哪些？\u003c/p\u003e\n\u003cp\u003e如果是电脑上，有鼠标、键盘、手柄；主机上主要是手柄；移动设备上则是屏幕、加速度计、陀螺仪。\u003c/p\u003e\n\u003cp\u003e除此之外，还有一些比较特殊的反馈，例如PC手柄的基础振动，PS平台的手柄还支持力反馈和吹气，移动端也可以触发手机的振动等。\u003c/p\u003e","title":"Unity Input System"},{"content":"1. Compute Shader 通常我们的游戏逻辑是跑在CPU上的，但是有一些非常适合并行计算的操作，比如各种粒子运动、流体/布料模拟、大量 AI 行为等，更适合跑在 GPU 上。这是因为 GPU 的核心数量非常多，天然更适合处理能够进行并行的计算。\n除了上面所示的一些计算，还有比如图像处理也可以用 Compute Shader，比如某种卷积，某种上色，傅里叶变换等等。\n这里值得一提的是，优化这个东西，除非你非常明确这个地方有优化的必要，否则不需要进行过早优化。例如 sin/cos 这些函数在计算的时候，是否用 CPU 计算还是用 GPU 在 Compute Shader 中计算，可能会有重复计算导致的效率上的差别，但是除了计算还有访问显存和内存造成的通信延时等等，而且不同 GPU 的硬件架构也不同，所以在不同类型的机器上效果未必一样。\n1.1 Compute Shader 代码 首先，在 Unity 中创建一个 Red.compute 文件，这个后缀所指的文件就是 Compute Shader\n#pragma kernel CSMain RWTexture2D\u0026lt;float4\u0026gt; Result; [numthreads(8,8,1)] void CSMain (uint3 id : SV_DispatchThreadID) { Result[id.xy] = float4(1,0,0,1); } 下面简单介绍下代码做了什么。\n#pragma kernel CSMain 是 Compute Shader 的入口声明，CSMain 是 kernel 的名字，表示 GPU 调用时执行的函数，后面你会通过 C# Script 来调用这个函数。\nRWTexture2D\u0026lt;float4\u0026gt; Result; 定义了一个 可读写的 2D 纹理（RenderTexture）作为输出，RWTexture2D\u0026lt;float4\u0026gt; 表示每个像素是一个 float4 向量（RGBA 浮点数）。\n通过 SetTexture 可以把 Unity 中的 RenderTexture 绑定到这个变量，RW 表示它可以随机写（Random Write），Compute Shader 内可以随意写任意像素。\n[numthreads(8,8,1)] void CSMain (uint3 id : SV_DispatchThreadID) 指定每个线程组（thread group）里包含的线程数，总线程数 = (threadGroupsX * 8, threadGroupsY * 8, threadGroupsZ * 1)，这里的具体含义在调用部分会更好理解。\nid 是全局线程 ID（不是组内线程 ID），比如 (256, 256, 1) 大小的数据如果通过 numthreads(8,8,1) 处理，id.x 的范围还是从 0 到 255 。\nResult[id.xy] = float4(1,0,0,1); 把当前线程对应像素写成 红色。\n1.2 调用 Compute Shader 首先获取 kernelID，然后通过 computeShader.Dispatch 语法进行调用。\n这里的 threadsX/Y/Z 对应的是 Compute Shader里面的 [numthreads(8,8,1)]。\n使用 computeShader.Dispatch 时需要知道总共的 id 范围是 groupSize * groupNumber，这里是 256/8 x 256/8 个线程组。\nusing UnityEngine; namespace Scenes.ComputeShaders.Test { public class RenderRedComputeShader: MonoBehaviour { public ComputeShader computeShader; public RenderTexture target; public Material material; void Start() { target = new RenderTexture(256, 256, 0); target.enableRandomWrite = true; target.Create(); int kernelID = computeShader.FindKernel(\u0026#34;CSMain\u0026#34;); computeShader.SetTexture(kernelID, \u0026#34;Result\u0026#34;, target); material.SetTexture(\u0026#34;_MainTex\u0026#34;, target); // 启动 GPU 线程：这里是 256/8 x 256/8 个线程组 computeShader.GetKernelThreadGroupSizes(kernelID, out uint threadsX, out uint threadsY, out _); computeShader.Dispatch(kernelID, 256 / (int)threadsX, 256 / (int)threadsY, 1); } } } material.SetTexture 同时把这个纹理给绑定到了材质上。这里用到的材质就单纯接收这个纹理并且输出出来。\n脚本按照下面的方式绑定 Compute Shader 和 Material。\n运行游戏后，得到结果：\n如果我们修改 Compute Shader 改为渐变 2 个通道。\n#pragma kernel CSMain RWTexture2D\u0026lt;float4\u0026gt; Result; [numthreads(8,8,1)] void CSMain (uint3 id : SV_DispatchThreadID) { uint width, height; Result.GetDimensions(width, height); float u = id.x / (float)(width - 1); float v = id.y / (float)(height - 1); float4 color = float4(u, v, 0, 1); Result[id.xy] = color; } 那么就会得到一张渐变图：\n1.3 在 Editor 中使用 Compute Shader 并不是只有在游戏运行的过程中才可以调用 Compute Shader，在 Editor 中同样可以。\n例如我们可以创建这样一个工具：\n代码如下：\nusing UnityEngine; using UnityEditor; using System.IO; public class CreateGradientPNG : EditorWindow { public ComputeShader computeShader; public int width = 512; public int height = 512; public string fileName = \u0026#34;GeneratedGradient.png\u0026#34;; [MenuItem(\u0026#34;Tools/Create Gradient PNG\u0026#34;)] public static void ShowWindow() { GetWindow\u0026lt;CreateGradientPNG\u0026gt;(\u0026#34;Create Gradient PNG\u0026#34;); } void OnGUI() { computeShader = (ComputeShader)EditorGUILayout.ObjectField(\u0026#34;Compute Shader\u0026#34;, computeShader, typeof(ComputeShader), false); width = EditorGUILayout.IntField(\u0026#34;Width\u0026#34;, width); height = EditorGUILayout.IntField(\u0026#34;Height\u0026#34;, height); fileName = EditorGUILayout.TextField(\u0026#34;File Name\u0026#34;, fileName); if (GUILayout.Button(\u0026#34;Generate PNG\u0026#34;)) { if (computeShader == null) { Debug.LogError(\u0026#34;Please Select Compute Shader\u0026#34;); return; } GeneratePNG(); } } void GeneratePNG() { RenderTexture rt = new RenderTexture(width, height, 0, RenderTextureFormat.ARGBFloat); rt.enableRandomWrite = true; rt.Create(); int kernel = computeShader.FindKernel(\u0026#34;CSMain\u0026#34;); computeShader.SetTexture(kernel, \u0026#34;Result\u0026#34;, rt); int threadX = 8; int threadY = 8; int groupsX = Mathf.CeilToInt(width / (float)threadX); int groupsY = Mathf.CeilToInt(height / (float)threadY); computeShader.Dispatch(kernel, groupsX, groupsY, 1); RenderTexture.active = rt; Texture2D tex = new Texture2D(width, height, TextureFormat.RGBAFloat, false); tex.ReadPixels(new Rect(0, 0, width, height), 0, 0); tex.Apply(); RenderTexture.active = null; // Save to PNG byte[] bytes = tex.EncodeToPNG(); string path = Path.Combine(Application.dataPath, fileName); File.WriteAllBytes(path, bytes); AssetDatabase.Refresh(); Debug.Log(\u0026#34;PNG 已生成：\u0026#34; + path); // Clear RenderTexture rt.Release(); DestroyImmediate(tex); } } 点击后就可以生成 Compute Shader 所计算出的图像：\n1.4 GPU 图元类型 如果你写过 Unity Shader 的代码，你应该会很熟悉 Shader 的两个部分：顶点着色器和片元着色器。\n但是，通常经历过的顶点着色器是控制的一个三角形的三个点的变化。\n在计算机图形学和 GPU 渲染管线中，图元是 GPU 用来描述几何形状的基本单元。GPU 会根据图元类型把顶点数据组合成几何图形，然后进行光栅化、着色等操作。不同的图元类型决定了顶点如何组合成图形。\n使用 Graphics.RenderPrimitives 可以绘制各种图元，包括点、线、面、三角形。\nrp = new RenderParams(material); rp.worldBounds = new Bounds(Vector3.zero, 10000*Vector3.one); Graphics.RenderPrimitives(rp, MeshTopology.Points, 1, particleCount ); // RenderParams The parameters Unity uses to render the primitives. // topology Primitive topology (for example, triangles or lines). // vertexCount\tThe number of vertices per instance. // instanceCount\tThe number of instances to render. 利用 RenderParams 来定义绘制的各种参数，比如用哪种材质，渲染的范围，渲染的摄像机等。\n它生成的每个实例的点的位置都是默认的，所以这个 RenderPrimitives 生成的这些点我们需要在材质中的顶点着色器去定义它们实际的位置。\n比如下列的 Shader 片段，它在顶点着色器的输出中有一个 PSIZE ，它定义的是点的大小。\nstruct Attributes { float4 positionOS : POSITION; uint instanceID : SV_InstanceID; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float4 positionHCS : SV_POSITION; float size: PSIZE; }; Varyings vert(Attributes IN) { Varyings OUT; Particle particle = particleBuffer[IN.instanceID]; OUT.positionHCS = TransformObjectToHClip(particle.position); OUT.size = 1; return OUT; } 2. 并行计算 本文的重点主要是在 Compute Shader 如何使用，并不是深入研究算法之类的内容。\n案例都来自 Unity 官方的 \u0026ldquo;Create popular shaders and visual effects with the Universal Render Pipeline\u0026rdquo;1。\n可以参考视频2和 GitHub3 代码。\n2.1 百万粒子 首先是百万个点，它们将在鼠标周围的位置随机产生，然后倾向于往鼠标方向增加移动速度。\n在 Compute Shader 和 粒子的 Shader 中，都会有这么一段：\nstruct Particle { float3 position; float3 velocity; float life; }; // In Compute Shader RWStructuredBuffer\u0026lt;Particle\u0026gt; particleBuffer; // In Shader StructuredBuffer\u0026lt;Particle\u0026gt; particleBuffer; 区别是 Compute Shader 中开启了 RW 随机写入功能，而 Shader 中只需要读取粒子的位置速度和声明周期。\n在调用的 C# 脚本中，创建了 ComputeBuffer，ComputeBuffer 是 Unity 提供的一种 GPU 缓冲区对象，主要用于在 C# 脚本和 GPU（Compute Shader / Shader）之间传递数据。它可以理解为一块分配在 GPU 内存上的数组缓冲区，支持高效地存取大量结构化数据。\n下面首先创建它，然后分别绑定给两者。\nstruct Particle { public Vector3 position; public Vector3 velocity; public float life; } void Init() { // initialize the particles Particle[] particleArray = new Particle[particleCount]; // ... } // ... particleBuffer = new ComputeBuffer(particleCount, SIZE_PARTICLE); particleBuffer.SetData(particleArray); computeShader.SetBuffer(kernelID, \u0026#34;particleBuffer\u0026#34;, particleBuffer); material.SetBuffer(\u0026#34;particleBuffer\u0026#34;, particleBuffer); rp = new RenderParams(material); rp.worldBounds = new Bounds(Vector3.zero, 10000*Vector3.one); Graphics.RenderPrimitives(rp, MeshTopology.Points, 1, particleCount); 最后，调用 RenderPrimitives 用指定的 Shader 把这些 ComputeBuffer 所对应的粒子画出来就可以了。\nShader 中根据 instanceID 提取出 particleBuffer 的值，然后做相关变换，然后绘制。这里关联有 GPU 实例化 的相关概念，建议查阅下资料。SV_InstanceID 就是用于将 instanceID 输入标记为GPU的实例ID。UNITY_VERTEX_INPUT_INSTANCE_ID 直接理解为一种需要设置的宏就可以了，实际上它展开就等价于设置instanceID : SV_InstanceID，这里实际上不起效果。\nstruct Attributes { float4 positionOS : POSITION; uint instanceID : SV_InstanceID; UNITY_VERTEX_INPUT_INSTANCE_ID }; Varyings vert(Attributes IN) { Varyings OUT; Particle particle = particleBuffer[IN.instanceID]; float lerpVal = particle.life * 0.25f; OUT.color = half4(1.0f - lerpVal+0.1, lerpVal+0.1, 1.0f, lerpVal); OUT.positionHCS = TransformObjectToHClip(particle.position); OUT.size = _PointSize; return OUT; } half4 frag(Varyings IN) : SV_Target { return IN.color; } 2.2 鸟群算法 Boids Boids（鸟群算法）是 Craig Reynolds 在 1986 年提出的一种模拟群体行为的算法，用来再现鸟群、鱼群等群体运动。它的核心是基于个体（Boid）的局部规则，而不是全局控制。主要有三条基本规则：\n分离（Separation） 避免和邻近个体距离太近，防止碰撞。 个体遍历附近的单位，根据距离计算斥力。\n对齐（Alignment） 尽量朝着邻居平均的方向飞行，使群体保持一致的移动趋势。 个体遍历附近的单位，将方向渐渐对齐附近单位的平均方向。\n凝聚（Cohesion） 朝向邻居的中心靠拢，保持群体的整体性。 个体遍历附近的单位计算它们的几何中心，将位置渐渐对齐这个中心点。\n这三条规则结合起来，就能产生出自然的群体行为效果，而无需全局规划。当然，这三条基本原则实现的时候，主要通过这三条规则调整一个综合目标方向，然后个体渐渐朝向这个目标方向，同时根据时间来计算在这个方向上的位移。\n在这个演示中，共享的是位置和速度，在 Compute Shader 中计算出这两个值后，再在 Shader 中通过矩阵变换顶点，渲染出来。\nstruct Boid { float3 position; float3 direction; float noise_offset; }; RWStructuredBuffer\u0026lt;Boid\u0026gt; boidsBuffer; 算法计算上，对每个点都会遍历其他所有点，然后计算 Boids 算法对应的三个规则，计算出方向和位移。\n[numthreads(256,1,1)] void CSMain (uint3 id : SV_DispatchThreadID) { Boid boid = boidsBuffer[id.x]; float3 separation = 0; float3 alignment = 0; float3 cohesion = flockPosition; uint nearbyCount = 1; // Add self that is ignored in loop for (uint i = 0; i \u0026lt; (uint)boidsCount; i++) { if (i == id.x) continue; Boid tempBoid = boidsBuffer[i]; float dist = distance(boid.position, tempBoid.position); if (dist \u0026lt; neighbourDistance) { float3 offset = boid.position - tempBoid.position; dist = max(dist, 0.000001);//Avoid division by zero separation += offset * (1.0/dist - 1.0/neighbourDistance); alignment += tempBoid.direction; cohesion += tempBoid.position; nearbyCount += 1; } } float avg = 1.0 / nearbyCount; alignment *= avg; cohesion *= avg; cohesion = normalize(cohesion - boid.position); float3 direction = alignment + separation + cohesion; boid.direction = lerp(normalize(boid.direction), direction, 0.01); boid.position += (boid.direction * boidSpeed * deltaTime); boidsBuffer[id.x] = boid; } 在 Shader 中依然是通过读取 ComputeBuffer 里的值，去移动顶点（或者构建一个旋转移动矩阵），之后就都是正常的渲染过程了。\nfloat4x4 create_matrix(float3 pos, float3 dir, float3 up) { float3 zaxis = normalize(dir); float3 xaxis = normalize(cross(up, zaxis)); float3 yaxis = cross(zaxis, xaxis); return float4x4( xaxis.x, yaxis.x, zaxis.x, pos.x, xaxis.y, yaxis.y, zaxis.y, pos.y, xaxis.z, yaxis.z, zaxis.z, pos.z, 0, 0, 0, 1 ); } Boid boid = boidsBuffer[input.instanceID]; float4x4 mat = create_matrix(boid.position, boid.direction, float3(0.0, 1.0, 0.0)); 然后接下来实践上的关键是，如何绘制这么多 Mesh 呢？\n利用 Graphics.RenderMeshIndirect，设置好渲染的数量和材质即可。RenderMeshIndirect 适合大规模、GPU 决定绘制，可以做真正的大量粒子、草、GPU LOD，CPU 负担极小。与之相对的还有个 DrawMeshInstanced，每次渲染要传递进去矩阵，不太方便。\nargsBuffer = new GraphicsBuffer(GraphicsBuffer.Target.IndirectArguments, 1, GraphicsBuffer.IndirectDrawIndexedArgs.size); GraphicsBuffer.IndirectDrawIndexedArgs[] data = new GraphicsBuffer.IndirectDrawIndexedArgs[1]; // The number of vertex indices per instance. data[0].indexCountPerInstance = boidMesh.GetIndexCount(0); // The number of instances to render. data[0].instanceCount = (uint)numOfBoids; argsBuffer.SetData(data); renderParams = new RenderParams(boidMaterial); renderParams.worldBounds = new Bounds(Vector3.zero, Vector3.one * 1000); Graphics.RenderMeshIndirect(renderParams, boidMesh, argsBuffer); 2.3 带有动画的单位 在 Compute Shader 中依然还是计算顶点位置，但是还多计算一个动画帧的值，根据速度、时间来插值。\nboid.frame = boid.frame + velocity * deltaTime * boidFrameSpeed; if (boid.frame \u0026gt;= numOfFrames) boid.frame -= numOfFrames; 同时在 Shader 中多一个 vertexAnimation 表示顶点动画，它是\nstruct Boid { float3 position; float3 direction; float noise_offset; float frame; float3 padding; }; StructuredBuffer\u0026lt;Boid\u0026gt; boidsBuffer; StructuredBuffer\u0026lt;float4\u0026gt; vertexAnimation; 应用的时候是读取 vertexAnimation 来得到应用动画后的位置，之后再进行 MVP。\n#ifdef FRAME_INTERPOLATION uint next = boid.frame + 1; if (next \u0026gt;= numOfFrames) next = 0; float frameInterpolation = frac(boidsBuffer[input.instanceID].frame); input.positionOS.xyz = lerp(vertexAnimation[input.vertexID * numOfFrames + boid.frame], vertexAnimation[input.vertexID * numOfFrames + next], frameInterpolation); #else input.positionOS.xyz = vertexAnimation[input.vertexID * numOfFrames + boid.frame]; #endif 这个系统里 Animator 的作用在初始化阶段就结束了，运行时 Boid 已经不再依赖 Unity 动画系统，而是完全依赖 GPU Buffer 中的烘焙顶点动画 + Boid 数据 来控制移动和播放动画。\n将蒙皮网格中的网格提取出来。\nboidSMR = boidObject.GetComponentInChildren\u0026lt;SkinnedMeshRenderer\u0026gt;(); boidMesh = boidSMR.sharedMesh; 烘焙然后存储每个节点的位置。\nanimator.Play(aniStateInfo.shortNameHash, iLayer, sampleTime); animator.Update(0f); boidSMR.BakeMesh(bakedMesh); for(int j = 0; j \u0026lt; vertexCount; j++) { Vector4 vertex = bakedMesh.vertices[j]; vertex.w = 1; vertexAnimationData[(j * numOfFrames) + i] = vertex; } 最后传递给 Shader 这个动画网格的变化坐标\nvertexAnimationBuffer.SetData(vertexAnimationData); boidMaterial.SetBuffer(\u0026#34;vertexAnimation\u0026#34;, vertexAnimationBuffer); Unity, Create popular shaders and visual effects with the Universal Render Pipeline, https://unity.com/resources/create-shaders-visual-effects-urp-unity-6\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUnity, URP Cookbook: Compute shaders - Part 1: Particle fun, https://www.youtube.com/watch?v=omZap7XHxKc\u0026ab_channel=Unity\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNikLever, GitHub, https://github.com/NikLever/Unity-URP-Cookbook-Unity6\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://cronrpc.github.io/zh/posts/unity-compute-shader/","summary":"\u003ch2 id=\"1-compute-shader\"\u003e1. Compute Shader\u003c/h2\u003e\n\u003cp\u003e通常我们的游戏逻辑是跑在CPU上的，但是有一些非常适合并行计算的操作，比如各种粒子运动、流体/布料模拟、大量 AI 行为等，更适合跑在 GPU 上。这是因为 GPU 的核心数量非常多，天然更适合处理能够进行并行的计算。\u003c/p\u003e","title":"Unity Compute Shader"},{"content":"1. 从傅里叶变换到拉普拉斯变换 1.1 傅里叶变换的局限 傅里叶变换的公式：\n$$ \\begin{aligned} F(\\omega) \u0026amp;= \\int_{-\\infin}^{\\infin}{f(t) e^{-j\\omega t} dt} \\end{aligned} $$\n其中的指数部分可以写为：\n$$ e^{-jwt}=\\cos{wt}-j\\sin{wt} $$\n但是对于函数比如 $f(t) = t^2$ 会发现根本积分不了，因为在无穷范围内积分的结果是无穷。\n经典的傅里叶变换（非广义定义）通常要求 绝对可积条件：\n$$ \\int_{-\\infin}^{\\infin} |f(t)| dt \u0026lt; \\infin $$\n在工程中有一些方法可以处理这种不收敛的函数：\n加窗：只在有限区间内考虑函数 专用拉普拉斯变换：拉普拉斯变换能处理发散情况，条件比傅里叶变换宽松。 那么如果还是希望能够分析这种函数，一个可行的方式是乘以某个指数函数，让它可以重新变成一个可积的函数。\n这里只考虑积分正半部分，拉普拉斯变换通常只考虑正半部分。\n有：\n$$ \\int_{0}^{\\infin}{e^{-3 t} t^2 dt} = \\frac{2}{27} $$\n满足 绝对可积条件 。\n如果我们将这个指数部分定义为 $\\sigma$，定义 $s = \\sigma + j\\omega$，指数部分可以表述为\n$$ e^{-\\sigma t}e^{-j\\omega t} = e^{-(\\sigma + j\\omega)t} = e^{-st} $$\n这就引出了下面的拉普拉斯变换。\n换句话说，傅里叶变换是拉普拉斯变换在 $\\sigma = 0$ 时的特殊形式。\n1.2 拉普拉斯变换 拉普拉斯变换（又称为拉式变换）是将时间域函数 $f(t)$（通常是 $t \\ge 0$ 的信号或函数）映射到复频域函数 $F(s)$ 的一种方法，公式为：\n$$ F(s) = \\mathcal{L}{f(t)} = \\int_{-\\infin}^{\\infin} f(t) e^{-st} dt $$\n其中：\n$t$ 是时间变量。 $s$ 是复频域变量，通常写作 $s = \\sigma + j\\omega$。 $F(s)$ 是 $f(t)$ 的拉普拉斯变换。 这里的符号 $\\mathcal{L}(f(t))$ 表示对 $f(t)$ 做拉普拉斯变换。\n如果把 $t^2 (t\u0026gt;0)$ 频域打印出来，高度用 $F(s)$ 的幅度表示（相位在这里确实也不关键），可以得到一张复平面上拉普拉斯变换的幅值图：\n拉普拉斯反变换：$F(s) \\to f(t)$\n$$ f(t) = \\frac{1}{2\\pi j} \\int_{\\gamma - j\\infin}^{\\gamma + j\\infin} F(s) e^{st} ds $$\n其中\n$\\gamma$ 是实轴上一个常数，使积分路径在 $F(s)$ 的所有奇点右侧 $s = \\sigma + j\\omega$ 这里补充说明下，奇点是指 $F(s)$ 不存在或者发散的点，比如 $F(s)=\\frac{2}{s^3}$ 的奇点是 $s = 0$。“右侧”意思是选一个实数 $\\gamma$，使得这条垂直线 $s = \\gamma + j\\omega$ 位于所有奇点的右边，这样积分路径经过的地方，$F(s)e^{st}$ 在积分方向上是收敛的（假定原本积分是 t \u0026gt; 0），如果路径穿过奇点，积分会发散或者不满足公式要求。\n1.3 单边拉普拉斯变换 工程领域，一般默认拉氏变换会对原函数先乘以阶跃函数再变换，阶跃函数是：\n$$ u(t)= \\begin{cases} \u0026amp;1, \u0026amp; t \\ge 0\\\\ \u0026amp;0, \u0026amp; t \\lt 0 \\end{cases} $$\n所以积分只需要在 $[0, +\\infin]$ 之间进行积分，这被称为 单边拉普拉斯变换。\n首先仔细推导一下 $f(x) = 1$ 的拉普拉斯变换。\n拉普拉斯变换的定义是：\n$$ \\mathcal{L}{f(t)} = F(s) = \\int_0^{\\infin} f(t) e^{-st} dt $$\n这里 $f(t) = 1$，所以：\n$$ \\mathcal{L}{1} = \\int_0^{\\infin} 1 \\cdot e^{-st} dt = \\int_0^{\\infin} e^{-st} dt $$\n这个积分可以直接计算：\n$$ \\int_0^{\\infin} e^{-st} dt = \\left[ -\\frac{1}{s} e^{-st} \\right]_0^{\\infin} $$\n当 $\\Re(s) \u0026gt; 0$ 且 $t \\to \\infin$ 时，$e^{-st} \\to 0$，所以：\n$$ \\int_0^{\\infin} e^{-st} dt = lim_{t \\to \\infin}{(-\\frac{1}{s} e^{-st})} - (-\\frac{1}{s} e^{-s \\cdot 0}) = 0 - \\left(-\\frac{1}{s}\\right) = \\frac{1}{s} $$\n结论：\n$$ \\boxed{\\mathcal{L}{1} = \\frac{1}{s}, \\quad \\Re(s) \u0026gt; 0} $$\n实际上我们并不需要一个个算，多数情况直接查表即可：\n时域 $f(t)$ 频域 $F(s)$ $u(t)$ $\\frac{1}{s}$ $u(t)e^{-at}$ $\\frac{1}{s+a}$ $t u(t)$ $\\frac{1}{s^2}$ $u(t) \\sin \\omega t$ $\\frac{\\omega}{s^2 + \\omega^2}$ $u(t) \\cos \\omega t$ $\\frac{s}{s^2 + \\omega^2}$ $u(t)e^{-at} \\sin \\omega t$ $\\frac{\\omega}{(s+a)^2 + \\omega^2}$ $u(t)e^{-at} \\cos \\omega t$ $\\frac{s+a}{(s+a)^2 + \\omega^2}$ 然后利用拉普拉斯变换的一些特性来求解。\n1.4 积分特性：变上限积分的频域 $$ \\mathcal{L} \\left( \\int_0^t{f(\\tau)d\\tau} \\right) = \\frac{F(s)}{s} $$\n证明如下：\n定义\n$$ g(t) = \\int_0^t f(\\tau) d\\tau $$\n根据拉普拉斯定义：\n$$ \\mathcal{L}{g(t)} = \\int_0^\\infin g(t) e^{-st} dt = \\int_0^\\infin \\left( \\int_0^t f(\\tau) d\\tau \\right) e^{-st} dt $$\n交换积分顺序\n$$ \\int_0^\\infin \\left( \\int_0^t f(\\tau) d\\tau \\right) e^{-st} dt = \\int_0^\\infin f(\\tau) \\left( \\int_\\tau^\\infin e^{-st} dt \\right) d\\tau $$\n计算内层积分\n$$ \\int_\\tau^\\infin e^{-st} dt = \\left[ \\frac{-1}{s} e^{-st} \\right]_{t=\\tau}^{t=\\infin} = \\frac{e^{-s\\tau}}{s} $$\n回代外层积分\n$$ \\mathcal{L}{g(t)} = \\int_0^\\infin f(\\tau) \\frac{e^{-s\\tau}}{s} d\\tau = \\frac{1}{s} \\int_0^\\infin f(\\tau) e^{-s\\tau} d\\tau = \\frac{F(s)}{s} $$\n1.5 微分特性：拉氏变换 n 阶导数公式 1 阶导数 对于 $f(t)$ 的导数，进行拉式变换可以得到：\n$$ \\mathcal{L}{f{\u0026rsquo;}(t)} = sF(s) - f(0) $$\n证明过程：\n从定义出发，\n$$ \\mathcal{L}{f\u0026rsquo;(t)}=\\int_0^\\infin f\u0026rsquo;(t)e^{-st} dt. $$\n做分部积分（取 $u=f(t),\\ dv=e^{-st}dt$），得到\n$$ \\int_0^\\infin f\u0026rsquo;(t)e^{-st}dt=\\Big[f(t)e^{-st}\\Big]_0^\\infin + s\\int_0^\\infin f(t)e^{-st}dt. $$\n在指数衰减条件下 $\\lim_{t\\to\\infin}f(t)e^{-st}=0$，因此边界项为 $-f(0)$。于是\n$$ \\mathcal{L}{f\u0026rsquo;(t)}=sF(s)-f(0), $$\n成立。\n这里提 2 点：\n有的时候把 $f(0)$ 写成 $f(0^{+})$，指的是 右侧极限，这里是强调是在 $ t \u0026gt; 0 $ 的范围，所以取右侧极限。 这里顺便提一下 $f(0)$ 在这里实际上是原函数中的直流分量，因为每求一阶导数，原函数中的常数项就消失了，$F(s)$ 是原函数的拉式变换，如果 $sF(s)$ 能表示导数的拉式变换，就肯定需要把原来的直流分量给去掉。 n 阶导数 对因果函数（因果函数在“系统开始响应之前没有任何输出”），有\n$$ \\mathcal{L}{f^{(n)}(t)}=s^n F(s)-s^{n-1}f(0)-s^{n-2}f\u0026rsquo;(0)-\\cdots-f^{(n-1)}(0), $$\n其中 $F(s)=\\mathcal{L}{f(t)}$，且 $f,f\u0026rsquo;,\\dots,f^{(n-1)}$ 在 $t=0^+$ 存在，且 $f$ 为指数阶使积分收敛。\n比如对于 2 阶导数\n$$ \\mathcal{L}{f\u0026rsquo;\u0026rsquo;(t)} = s^2 F(s) - s f(0) - f\u0026rsquo;(0), $$\n这个 n 阶的证明过程不在这里写了，通过归纳法可以证明。\n1.6 线性性质 拉普拉斯变换是线性的：\n$$ \\mathcal{L}{a f(t) + b g(t)} = a F(s) + b G(s) $$\n其中 $a, b$ 是常数，$F(s) = \\mathcal{L}{f(t)}$，$G(s) = \\mathcal{L}{g(t)}$。\n这意味着我们对每个分量套公式再做线性加减法，完全是可行的。\n2. 求解常微分方程 解微分方程：\n$$ y\u0026rsquo;\u0026rsquo; + 3y\u0026rsquo; + 2y = e^{-t}, \\quad y(0) = 0, \\quad y\u0026rsquo;(0) = 0 $$\n当然不止一种方法，这里介绍的是如何用拉普拉斯变换来解。\n拉普拉斯变换可以把微分运算转换成代数运算，从而把一个微分方程变成一个代数方程。\n因为拉普拉斯变换把原来的各种微分，都变成了 $sF(s)$ 所表达这种类似的形式。\n2.1 对方程进行拉普拉斯变换 令\n$$ \\mathcal{L}\\left[y(t)\\right] = Y(s) $$\n根据对导数求拉普拉斯变换的性质：\n$$ \\mathcal{L}{y\u0026rsquo;} = sY(s) - y(0) $$\n$$ \\mathcal{L}{y\u0026rsquo;\u0026rsquo;} = s^2 Y(s) - s y(0) - y\u0026rsquo;(0) $$\n代入初值 $y(0)=0, y\u0026rsquo;(0)=0$：\n$$ \\mathcal{L}{y\u0026rsquo;\u0026rsquo;} = s^2 Y(s) $$\n$$ \\mathcal{L}{3y\u0026rsquo;} = 3s Y(s) $$\n$$ \\mathcal{L}{2y} = 2 Y(s) $$\n$$ \\mathcal{L}{e^{-t}} = \\frac{1}{s+1} $$\n所以方程变为：\n$$ s^2 Y(s) + 3s Y(s) + 2 Y(s) = \\frac{1}{s+1} $$\n2.2 求解代数方程 提取 $Y(s)$：\n$$ Y(s) (s^2 + 3s + 2) = \\frac{1}{s+1} $$\n分解因式：\n$$ s^2 + 3s + 2 = (s+1)(s+2) $$\n所以：\n$$ Y(s) = \\frac{1}{(s+1)^2 (s+2)} $$\n2.3 反拉普拉斯变换 首先进行因式分解，因为拆分后才可以方便套公式直接做反拉普拉斯变换\n$$ \\frac{1}{(s+1)^2 (s+2)} = \\frac{A}{s+1} + \\frac{B}{(s+1)^2} + \\frac{C}{s+2} $$\n两边通分：\n$$ 1 = A(s+1)(s+2) + B(s+2) + C(s+1)^2 $$\n通过代入 $s=-1, -2$ 或系数比较，求出：\n$s=-1$ → $1 = B(1) \\Rightarrow B=1$ $s=-2$ → $1 = C(1) \\Rightarrow C=1$ 选择 $s=0$ → $1 = A(2) + B(2) + C(1) = 2A + 2 + 1 \\Rightarrow 2A = -2 \\Rightarrow A=-1$ 所以分解为：\n$$ Y(s) = \\frac{-1}{s+1} + \\frac{1}{(s+1)^2} + \\frac{1}{s+2} $$\n之后，做反拉普拉斯变换：\n$$ y(t) = \\mathcal{L}^{-1}{Y(s)} = -e^{-t} + t e^{-t} + e^{-2t} = t e^{-t} - e^{-t} + e^{-2t} $$\n最终结果：\n$$ y(t) = t e^{-t} - e^{-t} + e^{-2t} $$\n","permalink":"https://cronrpc.github.io/zh/posts/laplace-transform/","summary":"\u003ch2 id=\"1-从傅里叶变换到拉普拉斯变换\"\u003e1. 从傅里叶变换到拉普拉斯变换\u003c/h2\u003e\n\u003ch3 id=\"11-傅里叶变换的局限\"\u003e1.1 傅里叶变换的局限\u003c/h3\u003e\n\u003cp\u003e傅里叶变换的公式：\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\nF(\\omega) \u0026amp;= \\int_{-\\infin}^{\\infin}{f(t) e^{-j\\omega t} dt}\n\\end{aligned}\n$$\u003c/p\u003e\n\u003cp\u003e其中的指数部分可以写为：\u003c/p\u003e\n\u003cp\u003e$$\ne^{-jwt}=\\cos{wt}-j\\sin{wt}\n$$\u003c/p\u003e\n\u003cp\u003e但是对于函数比如 $f(t) = t^2$ 会发现根本积分不了，因为在无穷范围内积分的结果是无穷。\u003c/p\u003e","title":"Laplace Transform"},{"content":"1. 傅里叶变换 傅里叶变换起源于18世纪研究振动与热传导的问题。欧拉、达朗贝尔和伯努利提出用正弦波描述振动，奠定了思想基础。\n19世纪初，法国数学家傅里叶在研究热传导时提出任何函数都可展开为正弦与余弦级数，这就是傅里叶级数，并逐渐发展为傅里叶变换。\n1.1 函数的正交 如果是向量的正交，就是向量的内积为$0$。\n而函数的正交，我们以区间 $[-\\pi,\\pi]$ 为例；在 $[0,2\\pi]$ 或任意长度为 $2\\pi$ 的区间上结论相同\n定义定积分：\n$$ \\langle f,g\\rangle:=\\int_{-\\pi}^{\\pi} f(x)g(x) dx $$\n表示函数的内积，它的值如果为$0$，我们就称这两个函数在这个周期内正交。\n1.2 三角函数正交性 有如下函数\n$$ 1, cosx, sinx, cos2x, sin2x, cos3x, sin3x, \u0026hellip; $$\n其中 $1$ 也可以看成 $cos0x$ 。\n首先，我们知道，对于任何非零整数 $k$，都有\n$$ \\begin{aligned} \\int_{-\\pi}^{\\pi}\\cos kxdx \u0026amp; =0\\\\ \\int_{-\\pi}^{\\pi}\\sin kxdx \u0026amp; =0 \\end{aligned} $$\n因为它们在完整周期上的积分为零。所以 $1$ 与上述其他三角函数都是正交的。\n现在讨论三角函数之间的三种情况：\n$\\cos mx$ 与 $\\cos nx$ 的正交性 若 $m\\neq n$ 并且 $m\\neq 0, n\\neq 0$\n$$ \\begin{aligned} \\int_{-\\pi}^{\\pi}\\cos mx\\cos nxdx \u0026amp;=\\tfrac12\\int_{-\\pi}^{\\pi}\\big[\\cos(m-n)x+\\cos(m+n)x\\big]dx \\\\ \u0026amp;=0 \\end{aligned} $$\n$\\sin mx$ 与 $\\sin nx$ 的正交性 若 $m\\neq n$ 并且 $m\\neq 0, n\\neq 0$\n$$ \\begin{aligned} \\int_{-\\pi}^{\\pi}\\sin mx\\sin nxdx \u0026amp;=\\tfrac12\\int_{-\\pi}^{\\pi}\\big[\\cos(m-n)x-\\cos(m+n)x\\big]dx\\\\ \u0026amp;=0 \\end{aligned} $$\n$\\sin mx$ 与 $\\cos nx$ 互相正交 若 $m\\neq 0, n\\neq 0$\n$$ \\begin{aligned} \\int_{-\\pi}^{\\pi}\\sin mx\\cos nxdx \u0026amp;=\\tfrac12\\int_{-\\pi}^{\\pi}\\big[\\sin(m+n)x+\\sin(m-n)x\\big]dx\\\\ \u0026amp;=0 \\end{aligned} $$\n所以上述任意三角函数之间，都是正交的。\n现在来计算一下，与自身内积的结果：\n$$ \\int_{-\\pi}^{\\pi}\\cos^2 nxdx =\\tfrac12\\int_{-\\pi}^{\\pi}\\big[1+\\cos(2n x)\\big]dx =\\tfrac12\\big[2\\pi+0\\big]=\\pi. $$\n$$ \\int_{-\\pi}^{\\pi}\\sin^2 nxdx =\\tfrac12\\int_{-\\pi}^{\\pi}\\big[1-\\cos(2n x)\\big]dx =\\tfrac12\\big[2\\pi-0\\big]=\\pi. $$\n$$ \\int_{-\\pi}^{\\pi} 1\\cdot 1,dx=2\\pi $$\n总结：\n任意$m\\neq n$的三角函数之间正交。 三角函数在 $[-\\pi,\\pi]$ 周期的内积是 $\\pi$ $1$ 在 $[-\\pi,\\pi]$ 周期的内积是 $2\\pi$ 1.3 周期为 $2\\pi$ 的傅里叶级数展开 考虑一个周期函数，它的周期为$T = 2\\pi$，即满足$f(x)=f(x+2\\pi)$。\n那么它可以表示为三角级数的和：\n$$ \\begin{aligned} f(x) \u0026amp; = \\sum_{n=0}^{\\infin}{a_n \\cos{nx}}+\\sum_{n=0}^{\\infin}{b_n \\sin{nx}} \\\\ \u0026amp; = a_0 + \\sum_{n=1}^{\\infin}{a_n \\cos{nx}}+\\sum_{n=1}^{\\infin}{b_n \\sin{nx}} \\end{aligned} $$\n如何求出每个 $a_n$ 的值？可以利用正交性来求。\n在周期内进行内积，左右同时乘以 $1$ 并积分：\n$$ \\begin{aligned} \\int_{-\\pi}^{\\pi}{1 \\cdot f(x) dx} \u0026amp;= \\int_{-\\pi}^{\\pi}{a_0 dx} + \\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infin}{a_n \\cos{nx} dx}} + \\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infin}{b_n \\sin{nx} dx}} \\end{aligned} $$\n由于三角函数周期性，后面的三角函数都是积分结果都是 $0$，所以有：\n$$ \\begin{aligned} \\int_{-\\pi}^{\\pi}{f(x) dx} \u0026amp;= 2 \\pi a_0 \\\\ a_0 \u0026amp;= \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi}{f(x) dx} \\end{aligned} $$\n注意，这里有的教科书上，是令\n$$ \\begin{aligned} a_0 \u0026amp;= \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi}{f(x) dx} \\end{aligned} $$\n然后在公式阶段使用的是：\n$$ \\begin{aligned} f(x) \u0026amp; = \\frac{a_0}{2} + \\sum_{n=1}^{\\infin}{(a_n \\cos{nx}+ b_n \\sin{nx})} \\end{aligned} $$\n它们只是定义习惯，实际上没啥区别。我们后面采用这个定义的方式。\n接下来求 $a_n$，依然是同时乘以对应的三角函数然后在周期内进行积分，假设我们要求的是 $n=m$ 时的 $a_m$，依据三角函数正交性：\n$$ \\begin{aligned} \\int_{-\\pi}^{\\pi}{f(x) \\cos{mx} dx} =\u0026amp; \\int_{-\\pi}^{\\pi}{a_0 \\cos{mx} dx} \\\\ \u0026amp;+ \\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infin}{a_n \\cos{nx} \\cos{mx} dx}} \\\\ \u0026amp;+ \\int_{-\\pi}^{\\pi}{\\sum_{n=1}^{\\infin}{b_n \\sin{nx} \\cos{mx} dx}} \\\\ =\u0026amp; 0 + \\int_{-\\pi}^{\\pi}{a_m \\cos^2{mx}dx} + 0 \\\\ =\u0026amp; a_m \\pi \\end{aligned} $$\n所以有：\n$$ \\begin{aligned} a_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}{f(x) \\cos{nx} dx} \\end{aligned} $$\n同理 $b_n$ 也可以求出：\n$$ \\begin{aligned} b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}{f(x) \\sin{nx} dx} \\end{aligned} $$\n最后，结论如下：\n一个周期为 $2\\pi$的函数 $f(x)$，可以通过三角函数展开：\n$$ \\begin{aligned} f(x) \u0026amp; = \\frac{a_0}{2} + \\sum_{n=1}^{\\infin}{a_n \\cos{nx}} + \\sum_{n=1}^{\\infin}{b_n \\sin{nx}} \\end{aligned} $$\n其中：\n$$ \\begin{aligned} a_0 \u0026amp;= \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi}{f(x) dx} \\\\ a_n \u0026amp;= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}{f(x) \\cos{nx} dx} \\\\ b_n \u0026amp;= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}{f(x) \\sin{nx} dx} \\end{aligned} $$\n1.4 周期为 $2L$ 的傅里叶级数展开 上一小节探讨的是在 $2\\pi$ 为周期的函数上的三角级数展开，而我们希望可以在任意周期上进行展开。\n设原始函数 $f(t)$ 的周期是 $[-L, L]$，如果我们希望一个中间变量 $x$ 的周期是 $[-\\pi, \\pi]$，那么就可以令：\n$$ \\begin{aligned} x \u0026amp;= \\frac{\\pi}{L}t \\\\ t \u0026amp;= \\frac{L}{\\pi}x \\end{aligned} $$\n此时有，\n$$ f(t) = f(\\frac{L}{\\pi}x) \\overset{\\triangle}{=} g(x) $$\n根据在前面的推导中有：\n$$ \\begin{aligned} g(x) \u0026amp; = \\frac{a_0}{2} + \\sum_{n=1}^{\\infin}{a_n \\cos{nx}} + \\sum_{n=1}^{\\infin}{b_n \\sin{nx}}\\\\ a_0 \u0026amp;= \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi}{g(x) dx} \\\\ a_n \u0026amp;= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}{g(x) \\cos{nx} dx} \\\\ b_n \u0026amp;= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}{g(x) \\sin{nx} dx} \\end{aligned} $$\n统统做如下的替换，\n$$ \\begin{aligned} x \u0026amp;= \\frac{\\pi}{L}t\\\\ \\Rightarrow dx \u0026amp;= \\frac{\\pi}{L}dt \\end{aligned} $$\n以及\n$$ nx = n\\frac{\\pi}{L}t = (\\frac{n\\pi}{L})t $$\n于是有，\n$$ \\begin{aligned} f(t) \u0026amp; = \\frac{a_0}{2} + \\sum_{n=1}^{\\infin}{a_n \\cos{\\frac{n\\pi}{L}t}} + \\sum_{n=1}^{\\infin}{b_n \\sin{\\frac{n\\pi}{L}t}}\\\\ a_0 \u0026amp;= \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi}{g(x) dx}\\\\ \u0026amp;= \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi}{f(\\frac{L}{\\pi}x) dx}\\\\ \u0026amp;= \\frac{1}{\\pi} \\int_{-L}^{L}{f(t) \\frac{\\pi}{L} dt} \\\\ \u0026amp;= \\frac{1}{L} \\int_{-L}^{L}{f(t) dt} \\end{aligned} $$\n同理， $$ \\begin{aligned} a_n \u0026amp;= \\frac{1}{L}\\int_{-L}^{L}{f(t) \\cos{\\frac{n\\pi}{L}t} dt} \\\\ b_n \u0026amp;= \\frac{1}{L}\\int_{-L}^{L}{f(t) \\sin{\\frac{n\\pi}{L}t} dt} \\end{aligned} $$\n在工程领域中，习惯从 $0$ 开始积分，记\n$$ T=2L\\\\ \\\\ \\omega = \\frac{\\pi}{L} = \\frac{2\\pi}{T} $$\n于是三角级数展开又可以写为：\n$$ \\begin{aligned} f(t) \u0026amp; = \\frac{a_0}{2} + \\sum_{n=1}^{\\infin}{a_n \\cos{n\\omega t}} + \\sum_{n=1}^{\\infin}{b_n \\sin{n\\omega t}}\\\\ a_0 \u0026amp;= \\frac{2}{T} \\int_{0}^{T}{f(t) dt}\\\\ a_n \u0026amp;= \\frac{2}{T}\\int_{0}^{T}{f(t) \\cos{n\\omega t} dt} \\\\ b_n \u0026amp;= \\frac{2}{T}\\int_{0}^{T}{f(t) \\sin{n\\omega t} dt} \\end{aligned} $$\n1.5 复数形式的傅里叶级数展开 根据欧拉公式\n$$ e^{i\\theta}=\\cos\\theta+i\\sin\\theta $$\n得到\n$$ \\begin{aligned} \\cos\\theta\u0026amp;=\\frac{1}{2}(e^{i\\theta}+e^{-i\\theta})\\\\ \\sin\\theta\u0026amp;=-\\frac{1}{2}i(e^{i\\theta}-e^{-i\\theta}) \\end{aligned} $$\n代入到公式中得到：\n$$ \\begin{aligned} f(t) \u0026amp; = \\frac{a_0}{2} + \\sum_{n=1}^{\\infin}{a_n \\cos{n\\omega t}} + \\sum_{n=1}^{\\infin}{b_n \\sin{n\\omega t}}\\\\ \u0026amp;=\\frac{a_0}{2} + \\sum_{n=1}^{\\infin}{[a_n\\frac{1}{2}(e^{in\\omega t}+e^{-in\\omega t}) - \\frac{1}{2}ib_n(e^{in\\omega t}-e^{-in\\omega t})]}\\\\ \u0026amp;=\\frac{a_0}{2} + \\sum_{n=1}^{\\infin}{\\frac{a_n-ib_n}{2}e^{in\\omega t}} + \\sum_{n=1}^{\\infin}{\\frac{a_n+ib_n}{2}e^{-in\\omega t}}\\\\ \u0026amp;=\\frac{a_0}{2}e^{0}+\\sum_{n=1}^{\\infin}{\\frac{a_n-ib_n}{2}e^{in\\omega t}} + \\sum_{n=-\\infin}^{-1}{\\frac{a_{-n}+ib_{-n}}{2}e^{in\\omega t}}\\\\ \u0026amp;=\\sum_{-\\infin}^{\\infin}{c_n e^{in\\omega t}} \\end{aligned} $$\n其中 $c_n$ 定义为：\n$$ c_n = \\begin{cases} \\frac{a_0}{2}, \u0026amp; n = 0\\\\ \\frac{a_n-ib_n}{2}, \u0026amp; n = 1,2,3,4,\u0026hellip;\\\\ \\frac{a_{-n}+ib_{-n}}{2}, \u0026amp; n = -1,-2,-3,-4,\u0026hellip; \\end{cases} $$\n现在具体计算一下 $c_n$，\n$$ \\begin{aligned} \\underset{n=1,2,3,\u0026hellip;}{c_n} \u0026amp;= \\frac{1}{2}[\\frac{2}{T}\\int_{0}^{T}{f(t) \\cos{n\\omega t} dt} -i\\frac{2}{T}\\int_{0}^{T}{f(t) \\sin{n\\omega t} dt}]\\\\ \u0026amp;= \\frac{1}{T}\\int_{0}^{T}{f(t) (\\cos{n\\omega t}-i\\sin{n\\omega t}) dt}\\\\ \u0026amp;= \\frac{1}{T}\\int_{0}^{T}{f(t) (\\cos{(-n\\omega t)} + i\\sin{(-n\\omega t)}) dt}\\\\ \u0026amp;= \\frac{1}{T}\\int_{0}^{T}{f(t) e^{-in\\omega t} dt} \\end{aligned} $$\n$$ \\begin{aligned} \\underset{n=-1,-2,-3,\u0026hellip;}{c_n} \u0026amp;= \\frac{1}{2}[\\frac{2}{T}\\int_{0}^{T}{f(t) \\cos{(-n\\omega t)} dt} +i\\frac{2}{T}\\int_{0}^{T}{f(t) \\sin{(-n\\omega t)} dt}]\\\\ \u0026amp;= \\frac{1}{T}\\int_{0}^{T}{f(t) (\\cos{(-n\\omega t)} + i\\sin{(-n\\omega t)}) dt}\\\\ \u0026amp;= \\frac{1}{T}\\int_{0}^{T}{f(t) e^{-in\\omega t} dt} \\end{aligned} $$\n$$ \\begin{aligned} \\underset{n=0}{c_n} \u0026amp;= \\frac{1}{2}[\\frac{2}{T} \\int_{0}^{T}{f(t) dt}]\\\\ \u0026amp;= \\frac{1}{T} \\int_{0}^{T}{f(t) dt}\\\\ \u0026amp;= \\frac{1}{T} \\int_{0}^{T}{f(t) e^{-i0\\omega t} dt}\\\\ \u0026amp;= \\frac{1}{T} \\int_{0}^{T}{f(t) e^{-in\\omega t} dt} \\end{aligned} $$\n所以 $c_n$ 都可以写为一样的形式：\n$$ c_n = \\frac{1}{T} \\int_{0}^{T}{f(t) e^{-in\\omega t} dt} $$\n总结：\n复数形式的傅里叶变换中，对于周期函数 $f(t) = f(t+T)$，有\n$$ \\begin{aligned} f(t) \u0026amp;= \\sum_{-\\infin}^{\\infin}{c_n e^{in\\omega t}} \\\\ c_n \u0026amp;= \\frac{1}{T} \\int_{0}^{T}{f(t) e^{-in\\omega t} dt} \\end{aligned} $$\n1.6 周期为 $\\infin$ 的傅里叶级数展开 周期为 $T$ 的函数\n$$ f_T(t) = f_T(t+T) $$\n可以被解析为下列表示\n这里用 $\\omega_0$ 表示基频率 $$ \\begin{aligned} f_T(t) \u0026amp;= \\sum_{-\\infin}^{\\infin}{c_n e^{in\\omega_0 t}} \\\\ c_n \u0026amp;= \\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}}{f_T(t) e^{-in\\omega_0 t} dt}\\\\ \\omega_0 \u0026amp;= \\frac{2\\pi}{T} \\end{aligned} $$\n现在的问题是，如果一个非周期函数，那么该怎么处理？\n不是周期函数，换个角度来说，就是周期无穷大，就是无穷大之后才会重复。\n我们直接把 $c_n$ 代入回去，同时令 $f(t) = \\underset{T \\to \\infin}{f_T}$，\n$$ \\begin{aligned} f(t) \u0026amp;= \\sum_{-\\infin}^{\\infin}{\\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}}{f(t) e^{-in\\omega_0 t} dt} e^{in\\omega_0 t}}\\\\ \u0026amp;= \\sum_{-\\infin}^{\\infin}{\\frac{\\omega_0}{2\\pi} \\int_{-\\infin}^{\\infin}{f(t) e^{-in\\omega_0 t} dt} e^{in\\omega_0 t}} \\end{aligned} $$\n令 $\\omega_0 = d\\omega$，那么 $n\\omega_0 = \\omega$，所以\n$$ \\begin{aligned} f(t) \u0026amp;= \\sum_{-\\infin}^{\\infin}{\\frac{\\omega_0}{2\\pi} \\int_{-\\infin}^{\\infin}{f(t) e^{-in\\omega_0 t} dt} e^{in\\omega_0 t}}\\\\ \u0026amp;= \\int_{-\\infin}^{\\infin}{\\frac{1}{2\\pi}\\int_{-\\infin}^{\\infin}{f(t) e^{-iomega t} dt} e^{i\\omega t} d\\omega}\\\\ \u0026amp;= \\int_{-\\infin}^{\\infin}{\\frac{1}{2\\pi} \\left( \\int_{-\\infin}^{\\infin}{f(t) e^{-i\\omega t} dt} \\right) e^{i\\omega t} d\\omega}\\\\ \u0026amp;= \\frac{1}{2\\pi} \\int_{-\\infin}^{\\infin}{\\left( \\int_{-\\infin}^{\\infin}{f(t) e^{-i\\omega t} dt} \\right) e^{i\\omega t} d\\omega} \\end{aligned} $$\n这里定义 $F(\\omega)$，就得到傅里叶变换的最终形式\n$$ \\begin{aligned} F(\\omega) \u0026amp;= \\int_{-\\infin}^{\\infin}{f(t) e^{-i\\omega t} dt} \\end{aligned} $$\n而逆变换是\n$$ \\begin{aligned} f(t) \u0026amp;= \\frac{1}{2\\pi} \\int_{-\\infin}^{\\infin}{ F(\\omega) e^{i\\omega t} d\\omega} \\end{aligned} $$\n1.7 对称形式、工程学派、频率形式 在上面的傅里叶变换中，我们把 $2\\pi$ 放在逆变换中，实际上还有下列的形式：\n对称形式（常用在数学里），把 $2\\pi$ 均分到正变换和逆变换： $$ F(\\omega) = \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{\\infty} f(t)e^{-i\\omega t} dt $$\n$$ f(t) = \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{\\infty} F(\\omega)e^{i\\omega t} d\\omega $$\n工程学派（常见于电气工程/信号处理），把 $2\\pi$ 放在正变换中，逆变换没有 $2\\pi$： $$ F(\\omega) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} f(t)e^{-i\\omega t} dt $$\n$$ f(t) = \\int_{-\\infty}^{\\infty} F(\\omega)e^{i\\omega t} d\\omega $$\n周期形式（用频率 $f$ 而不是角频率 $\\omega$），如果令 $\\omega = 2\\pi f$，就可以写成： $$ F(f) = \\int_{-\\infty}^{\\infty} f(t)e^{-i 2\\pi f t} dt $$\n$$ f(t) = \\int_{-\\infty}^{\\infty} F(f)e^{i 2\\pi f t} df $$\n2. 离散傅里叶变换 在前面的讨论中，我们涉及到是连续函数和无穷频率。\n虽然前面已经学习了傅里叶变换的积分形式，但是实际工程中的最大问题是工程中的采样点不是连续函数。通常是离散的点。\n2.1 离散傅立叶变换 DFT 对于一个离散的采样点，比如 N 个点的序列 $x[n]$，直接认为它的周期就是 N。\n已知周期为 T 的傅里叶变换形式是：\n$$ \\begin{aligned} c_n \u0026amp;= \\frac{1}{T}\\int_{0}^{T}{f(t) e^{-in\\omega t} dt}\\\\ f(t) \u0026amp;= \\sum_{n=-\\infin}^{\\infin}{c_n e^{in\\omega t}} \\end{aligned} $$\n现在令 $\\omega = \\frac{2\\pi}{N}$，$T \\to N$，同时把 $\\frac{1}{T} \\to \\frac{1}{N}$ 这个常量移动到逆变换里面。同时原本的 n 用 k 表示，原本的 t 用序号 n 表示。\n$$ \\begin{aligned} X[k] \u0026amp;=\\sum_{n=0}^{N-1}{x[n] \\cdot e^{-j\\frac{2\\pi}{N}kn}}\\\\ x[n] \u0026amp;= \\frac{1}{N} \\sum_{k=0}^{N-1}{X[k]\\cdot e^{j\\frac{2\\pi}{N}kn}} \\end{aligned} $$\n其中 $k=0,1,2,\u0026hellip;,N-1$\n2.2 证明 DFT 成立 把 $X[k]$ 代入逆变换公式：\n$$ \\begin{aligned} x[n] \u0026amp;= \\frac{1}{N}\\sum_{k=0}^{N-1} X[k],e^{j\\frac{2\\pi}{N}kn} \\\\ \u0026amp;= \\frac{1}{N}\\sum_{k=0}^{N-1}\\left(\\sum_{m=0}^{N-1} x[m],e^{-j\\frac{2\\pi}{N}km}\\right)e^{j\\frac{2\\pi}{N}kn} \\\\ \u0026amp;= \\frac{1}{N}\\sum_{m=0}^{N-1} x[m]\\sum_{k=0}^{N-1} e^{j\\frac{2\\pi}{N}k(n-m)} \\end{aligned} $$\n考虑内层和\n$$ S_{n-m}=\\sum_{k=0}^{N-1} e^{j\\frac{2\\pi}{N}k(n-m)} $$\n令 $r=n-m$（整数）。若 $r\\equiv 0\\pmod N$（即 $n=m$），则每项都是 $1$，于是\n$$ S_{0}=N $$\n若 $r\\not\\equiv 0\\pmod N$，则这是一个首项为 $1$、公比 $q=e^{j\\frac{2\\pi}{N}r}\\neq1$ 的几何级数，\n$$ S_{r}=\\frac{1-q^{N}}{1-q}=\\frac{1-e^{j2\\pi r}}{1-q}=0 $$\n因为 $e^{j2\\pi r}=1$。因此\n$$ S_{n-m}= \\begin{cases} N,\u0026amp; n=m,\\\\ 0,\u0026amp; n\\ne m. \\end{cases} $$\n把它代回去：\n$$ x[n]=\\frac{1}{N}\\sum_{m=0}^{N-1} x[m]S_{n-m}=\\frac{1}{N}\\big(x[n]\\cdot N\\big)=x[n]. $$\n这就证明了逆变换确实把由前向变换得到的 $X[k]$ 恢复回原序列 $x[n]$。换句话说，复指数在这组离散点上是正交的，且\n$$ \\frac{1}{N}\\sum_{k=0}^{N-1} e^{j\\frac{2\\pi}{N}k(n-m)}=\\delta_{n,m} $$\n2.3 共轭对称性 $$ \\begin{aligned} X[k] \u0026amp;=\\sum_{n=0}^{N-1}{x[n] \\cdot e^{-j\\frac{2\\pi}{N}kn}} \\end{aligned} $$\n$X[k]$ 的共轭值为：\n$$ \\begin{aligned} X^{\\ast}[k] \u0026amp;=\\left( \\sum_{n=0}^{N-1}{x[n] \\cdot e^{-j\\frac{2\\pi}{N}kn}} \\right)^{\\ast} \\end{aligned} $$\n由于 $x[n]$ 是实数，所以\n$$ \\begin{aligned} X^{\\ast}[k] \u0026amp;=\\sum_{n=0}^{N-1}{x[n] \\cdot (e^{-j\\frac{2\\pi}{N}kn}})^{\\ast}\\\\ \u0026amp;=\\sum_{n=0}^{N-1}{x[n] \\cdot (e^{j\\frac{2\\pi}{N}kn}})\\\\ \u0026amp;=\\sum_{n=0}^{N-1}{x[n] \\cdot (e^{j\\frac{2\\pi}{N}(kn-Nn)}})\\\\ \u0026amp;=\\sum_{n=0}^{N-1}{x[n] \\cdot (e^{-j\\frac{2\\pi}{N}(N-k)n}})\\\\ \u0026amp;=X[N-k] \\end{aligned} $$\n结论：\n如果 $x[n]$ 是实数序列，则有\n$$ X[k] = X^*[N-k], \\quad k=1,2,\\dots,N-1 $$\n也就是说，DFT 的频谱是共轭对称的。\n还有一个有意思的结论，那就是当 N 是偶数的时候， $k = 0$ 和 $k = N/2$ 都只有实数部分的。\n$$ \\begin{aligned} X[N/2] \u0026amp;= X^{\\ast}[N-N/2] = N^{\\ast}[N/2]\\\\ \u0026amp;= \\Re{(X[N/2])} \\end{aligned} $$\n2.4 奈奎斯特采样定理 对长度为 $N$ 的序列 $x[n]$，其 DFT 是\n$$ X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j \\frac{2\\pi}{N}kn}, \\quad k = 0,1,\\dots,N-1 $$\n这里 $k$ 对应的是频率索引，实际频率为\n$$ f_k = \\frac{k}{N} f_s $$\n其中 $f_s$ 是采样率。\n根据奈奎斯特采样定理：\n连续信号在采样率 $f_s$ 下，最大能无失真恢复的频率是 $f_s/2$（奈奎斯特频率）。 也就是说，$0 \\leq f \\leq f_s/2$ 才是“有效”区间。 所以，DFT 给出的频率范围 $0 \\leq f \u0026lt; f_s$，其中一半其实是镜像频率。\n这个结论实际上和前面的共轭对称性也是符合的，有一半的频率实际上是冗余的。\n同时从信息的角度来说，$N$ 个实数可以通过 $\\frac{N}{2}$ 个复数来恢复信息，所以也是合理的。\n2.5 周期性与负频率 离散傅里叶变换 (DFT) 在频率域上具有 周期性。其定义为\n$$ X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j\\frac{2\\pi}{N}kn}, \\quad k=0,1,\\dots,N-1 $$\n如果将频率索引扩展到任意整数 $m$，则有\n$$ X[k+mN] = \\sum_{n=0}^{N-1} x[n] e^{-j\\frac{2\\pi}{N}(k+mN)n} = \\sum_{n=0}^{N-1} x[n] e^{-j\\frac{2\\pi}{N}kn} e^{-j2\\pi mn} $$\n由于 $e^{-j2\\pi mn} = 1$，因此\n$$ X[k+mN] = X[k] $$\n这表明 DFT 在频率索引上以 $N$ 为周期。换句话说，频谱在频率轴上是环形的，超过范围会自动折返。\n虽然 DFT 的索引 $k$ 只定义在 $[0, N-1]$，但通过周期性，可以自然引入“负频率”的概念。具体地：\n$$ X[-k] = X[N-k]\\\\ k=-1,-2,-3,\u0026hellip; $$\n结合前面的共轭对称性，可以发现一个有趣的现象：\n$$ X[-k] = X[N-k] = X^{\\ast}[k] $$\n即正负频率也呈现共轭对称性。\n因此，原本的索引\n$$ k = 0, 1, 2, \\dots, \\tfrac{N}{2}-1, \\tfrac{N}{2}, \\tfrac{N}{2}+1, \\dots, N-1 $$\n可以等价地写作\n$$ k = 0, 1, 2, \\dots, \\tfrac{N}{2}-1, \\tfrac{N}{2}, -\\tfrac{N}{2}+1, \\dots, -2, -1 $$\n3. 快速傅里叶变换 快速傅里叶变换（FFT）的思想最早可追溯到19世纪初。1805年，高斯在研究天体轨道时，已经提出过一种相当于 FFT 的高效算法，但他的工作仅以笔记形式保存，并未被广泛传播。之后一个多世纪里，离散傅里叶变换（DFT）仍以 $O(N^2)$ 的复杂度被直接计算。\n直到1965年，IBM 的 James Cooley 与 Princeton 的 John Tukey 在研究数值天气预报时重新发现并系统化了这一方法，他们意识到可以通过分治与旋转因子对称性，大幅减少计算量。论文发表后引起轰动，使大规模频域分析首次成为现实。\n有趣的是，FFT 并非“新算法”，而是对古老数学思想的复兴与推广。正是计算机硬件的兴起与实际需求的迫切，才让这项算法走出历史笔记，成为信号处理、通信、图像分析与科学计算中不可或缺的核心工具。\n3.1 离散傅里叶变换的复杂度 依据前面，离散傅里叶变换的定义为：\n$$ X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j \\frac{2\\pi}{N} kn}, \\quad k=0,1,\\dots,N-1 $$\n直接计算每个 $X[k]$ 需要 $N$ 次乘法以及 $N$ 项求和，总共有 $N$ 个 $k$，因此时间复杂度为：\n$$ \\mathcal{O}(N^2) $$\n当 $N$ 较大时，这样的复杂度难以接受。\n快速傅里叶变换（FFT）通过利用对称性和递归分治思想，将复杂度降到：\n$$ \\mathcal{O}(N \\log N) $$\n这也是其在信号处理、图像处理、数值计算等领域广泛应用的原因。\n3.2 旋转因子的性质 在 DFT 中，我们定义指数部分：\n$$ W_N = e^{-j \\frac{2\\pi}{N}} $$\n它被称为 旋转因子 (Twiddle Factor)，于是\n$$ W_N^{kn} = e^{-j \\frac{2\\pi}{N}kn} $$\n此时 DFT 公式可写为：\n$$ X[k] = \\sum_{n=0}^{N-1} x[n] W_N^{kn} $$\n旋转因子具有一些重要性质：\n周期性 $$ W_N^{a+N} = e^{-j \\frac{2\\pi}{N}(a+N)} = e^{-j \\frac{2\\pi}{N}(a)} e^{-j2\\pi} = e^{-j \\frac{2\\pi}{N}(a)} = W_N^a $$\n对称性 $$ W_N^{a+\\frac{N}{2}} = e^{-j \\frac{2\\pi}{N}(a+\\frac{N}{2})} = e^{-j \\frac{2\\pi}{N}(a)} e^{-j\\pi} = - e^{-j \\frac{2\\pi}{N}(a)} = - W_N^a $$\n缩放性 $$ W_N^{a} = e^{-j \\frac{2\\pi}{N}(a)} = e^{-j \\frac{2\\pi}{N/m}(a/m)} = W_{N/n}^{a/m} $$\n这些性质可以使得计算量大大减少。\n3.3 快速傅里叶变换推导式 下面我们就来看看旋转因子的这些性质是如何被使用的。\n设原始序列为 $x[n]$，长度为 $N$（假设 $N=2^m$ 为 2 的幂）。如果实际工程中遇到不满足 2 的幂的点，可以直接补零到 $N=2^m$ 长度，复原的时候截断后面的零即可。\n我们还是先回到原来的公式：\n$$ X[k] = \\sum_{n=0}^{N-1} x[n] W_N^{kn} $$\n拆分成奇数部分和偶数部分\n$$ \\begin{aligned} X[k] \u0026amp;= \\sum_{m=0}^{N/2-1} x[2m] \\cdot W_N^{k \\cdot 2m} + \\sum_{m=0}^{N/2-1} x[2m+1] \\cdot W_N^{k \\cdot (2m+1)} \\\\ \u0026amp; k=1,2,3,\u0026hellip;,N-1 \\end{aligned} $$\n这里定义一个专门用来取奇偶的函数，\n$$ \\begin{aligned} x_{even}(m)\u0026amp;=x(2m) \u0026amp; ,m=0,1,2,\u0026hellip;,N/2 - 1\\\\ x_{odd}(m)\u0026amp;=x(2m+1) \u0026amp; ,m=0,1,2,\u0026hellip;,N/2 - 1 \\end{aligned} $$\n同时提取出奇数部分的一个公共旋转因子：\n$$ \\begin{aligned} X[k] \u0026amp;= \\sum_{m=0}^{N/2-1} x_{even}(m) \\cdot W_N^{k \\cdot 2m} + W_N^k \\sum_{m=0}^{N/2-1} x_{odd}(m) \\cdot W_N^{k \\cdot (2m)}\\\\ \u0026amp;=\\sum_{m=0}^{N/2-1} x_{even}(m) \\cdot W_{N/2}^{k \\cdot m} + W_N^k \\sum_{m=0}^{N/2-1} x_{odd}(m) \\cdot W_{N/2}^{km}\\\\ \u0026amp; k=1,2,3,\u0026hellip;,N-1 \\end{aligned} $$\n定义\n$$ \\begin{aligned} X_{even}[k] \u0026amp;= \\sum_{m=0}^{N/2-1} x_{even}(m) \\cdot W_{N/2}^{k \\cdot m} \\\\ X_{odd}[k] \u0026amp;= \\sum_{m=0}^{N/2-1} x_{odd}(m) \\cdot W_{N/2}^{km} \\end{aligned} $$\n那么\n$$ \\begin{aligned} X[k] = X_{even}[k] + W_N^k X_{odd}[k] \u0026amp; , \u0026amp; k=0,1,2,\u0026hellip;,N-1\\\\ \\end{aligned} $$\n现在 $k$ 比 $m$ 要多一倍的取值范围，如果把 $k$ 也取一半，\n$$ \\begin{aligned} X[k] \u0026amp;= X_{even}[k] + W_N^k X_{odd}[k] \u0026amp; \u0026amp; k=0,1,2,\u0026hellip;,N/2-1\\\\ X[k+N/2] \u0026amp;= X_{even}[k+N/2] + W_N^{k+N/2} X_{odd}[k+N/2] \u0026amp; \u0026amp; k=0,1,2,\u0026hellip;,N/2-1\\\\ \\end{aligned} $$\n依据旋转因子的周期性和对称性（这里可以展开代入一下），后半部分又可以写为\n$$ \\begin{aligned} X[k+N/2] \u0026amp;= X_{even}[k] - W_N^{k} X_{odd}[k] \u0026amp; \u0026amp; k=0,1,2,\u0026hellip;,N/2-1 \\end{aligned} $$\n所以原始序列可以被分解为 2 个部分，前 $N/2$ 部分是偶数部分加奇数部分（乘以一个旋转因子），后 $N/2$ 部分是偶数部分减去奇数部分（乘以一个旋转因子）。\n还记得前面小节提到的共轭对称性吗？也是只需要算一半频率就可以求出另一半频率，这里实际上也是暗含了这种性质。\n但是这里我们还可以继续进行分解，比如偶数部分又可以拆分为两个部分的和\n$$ \\begin{aligned} X_{even}[k] \u0026amp;= \\sum_{m=0}^{N/2-1} x_{even}(m) \\cdot W_{N/2}^{k \\cdot m} \u0026amp; \u0026amp; k=0,1,2,\u0026hellip;,N/2-1\\\\ X_{even}[k] \u0026amp;= \\sum_{m=0}^{N/4-1} x_{even-even}(m) \\cdot W_{N/4}^{k \\cdot m} \\\\ \u0026amp;+ W_{N/2}^{k} \\sum_{m=0}^{N/4-1} x_{even-odd}(m) \\cdot W_{N/4}^{k \\cdot m} \u0026amp; \u0026amp; k=0,1,2,\u0026hellip;,N/2-1 \\end{aligned} $$\n以此类推：\n$$ \\begin{aligned} X_{even}[k] \u0026amp;= X_{even-even}(k) + W_{N/2}^{k} X_{even-odd}(k) \u0026amp; \u0026amp; k=0,1,2,\u0026hellip;,N/4-1\\\\ X_{even-even}[k] \u0026amp;= X_{even-even-odd}(k) + W_{N/4}^{k} X_{even-even-odd}(k) \u0026amp; \u0026amp; k=0,1,2,\u0026hellip;,N/8-1 \\end{aligned} $$\n可以不断进行递归，最终在 2 个值的时候，只有 1 个偶数和 1 个奇数。\n最后在只剩 1 个值的这一层的时候，直接返回值本身即可，因为此时没有奇数序列：\n$$ X_{\\text{final-even-index}} = x_{\\text{final-even-index}} $$\n最终的结果就符合上面的推导。\n实际上我们算一下 2 点的 DFT 就知道，就是一个加法和一个减法。\n比如 $[x0, x1]$ 两个点进行 DFT，\n$$ \\begin{aligned} X_0 \u0026amp;= x_0 \\cdot W_2^{0\\cdot0} + x_1 \\cdot W_2^{0\\cdot1} = x_0 \\cdot 1 + x_1 \\cdot 1 \u0026amp;= x_0 + x_1\\\\ X_1 \u0026amp;= x_0 \\cdot W_2^{1\\cdot0} + x_1 \\cdot W_2^{1\\cdot1} = x_0 \\cdot 1 + x_1 \\cdot (-1) \u0026amp;= x_0 - x_1 \\end{aligned} $$\n3.4 位反转重排 对于 8 个数的 FFT，按照下标序号分组的话：\n第一层：\n0 2 4 6 / 1 3 5 7 第二层：\n0 4 / 2 6 / 1 5 / 3 7 第三层：\n0 / 4 / 2 / 6 / 1 / 5 / 3 / 7 8个数可以用 3 个 bit 来表示，仔细观察会发现，第一层是通过最低位的奇偶性来分层的，相同的分在一组；第二层是第二位的奇偶性来分组；最后一层是第高位的奇偶性来分组。\n如果我们把位反转：\n0 -\u0026gt; 000 -\u0026gt; 000 -\u0026gt; 0 1 -\u0026gt; 001 -\u0026gt; 100 -\u0026gt; 4 2 -\u0026gt; 010 -\u0026gt; 010 -\u0026gt; 2 3 -\u0026gt; 011 -\u0026gt; 110 -\u0026gt; 6 4 -\u0026gt; 100 -\u0026gt; 001 -\u0026gt; 1 5 -\u0026gt; 101 -\u0026gt; 101 -\u0026gt; 5 6 -\u0026gt; 110 -\u0026gt; 011 -\u0026gt; 3 7 -\u0026gt; 111 -\u0026gt; 111 -\u0026gt; 7 通过重排 bit ，获得在内存中的连续块，正好满足迭代 FFT 的计算顺序。\n不过为了便于理解，我们后续的代码编写采用递归方式编写，不会进行该操作。\n3.5 算法复杂度分析 在每一层合并时，需要做 $N$ 次额外的“蝶形运算”（复加法 + 旋转因子乘法）。\n每一层根据奇偶性细分一半，所以总共有 $\\log_{2}{N}$ 层。\n综上，复杂度为：\n$$ \\mathcal{O}(N \\log N) $$\n3.6 IFFT $$ x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] e^{j \\frac{2\\pi}{N} kn}, \\quad n=0,1,\\dots,N-1 $$\n可以表示为：\n$$ \\begin{aligned} x[n] \u0026amp;= \\frac{1}{N} (\\sum_{k=0}^{N-1} (X[k])^{\\ast} (e^{j \\frac{2\\pi}{N} kn})^{\\ast})^{\\ast}\\\\ \u0026amp;= \\frac{1}{N} (\\sum_{k=0}^{N-1} (X[k])^{\\ast} e^{ -j \\frac{2\\pi}{N} kn})^{\\ast}\\\\ \u0026amp;= \\frac{1}{N} (\\text{FFT}((X[k])^{\\ast}))^{\\ast} \\end{aligned} $$\n如果用 Python 可以表示为：\nx = np.conj(np.fft.fft(np.conj(X))) / N 这里注意的一点是，如果输入序列是实数，那么 IFFT 返回只有实部，所以虚数可以不取。\n3.7 FFT Python Code 假定输入序列是 $N = 2^{m}$。\n有如下代码：\nimport numpy as np def fft(x): N = len(x) if N \u0026lt;= 1: return x X_even = fft(x[0::2]) X_odd = fft(x[1::2]) X = [0] * N for k in range(N//2): t = np.exp(-2j * np.pi * k / N) * X_odd[k] X[k] = X_even[k] + t X[k + N//2] = X_even[k] - t return X def ifft(X): N = len(X) x_time = np.conj(fft(np.conj(X))) / N return x_time if __name__ == \u0026#34;__main__\u0026#34;: x = [1,t(x) print(\u0026#34;FFT:\u0026#34;) for k, v in enumerate(X): print(f\u0026#34;X[{k:2d}] = {v.real:8.2f} + {v.imag:8.2f}j\u0026#34;) # IFFT x_rec = ifft(X) print(\u0026#34;\\nIFFT:\u0026#34;) for n, v in enumerate(x_rec): print(f\u0026#34;x[{n:2d}] = {v.real:8.2f} + {v.imag:8.2f}j\u0026#34;) 2, 3, 4, 5, 6, 7, 8] print(\u0026#34;x[n]: \u0026#34;, x, \u0026#34;\\n\u0026#34;) # FFT X = ff 结果为：\nx[n]: [1, 2, 3, 4, 5, 6, 7, 8] FFT: X[ 0] = 36.00 + 0.00j X[ 1] = -4.00 + 9.66j X[ 2] = -4.00 + 4.00j X[ 3] = -4.00 + 1.66j X[ 4] = -4.00 + 0.00j X[ 5] = -4.00 + -1.66j X[ 6] = -4.00 + -4.00j X[ 7] = -4.00 + -9.66j IFFT: x[ 0] = 1.00 + -0.00j x[ 1] = 2.00 + 0.00j x[ 2] = 3.00 + -0.00j x[ 3] = 4.00 + 0.00j x[ 4] = 5.00 + -0.00j x[ 5] = 6.00 + -0.00j x[ 6] = 7.00 + 0.00j x[ 7] = 8.00 + -0.00j 3.8 2D FFT IFFT 2D DFT 的定义\n设输入矩阵 $f[m,n]$ 大小为 $M \\times N$，2D DFT 定义为：\n$$ F[k,l] = \\sum_{m=0}^{M-1}\\sum_{n=0}^{N-1} f[m,n] , e^{-j 2\\pi \\left(\\frac{k m}{M} + \\frac{l n}{N}\\right)} $$\n注意指数是行方向 + 列方向的和。\n因为指数是可分解的：\n$$ e^{-j 2\\pi (\\frac{k m}{M} + \\frac{l n}{N})} = e^{-j 2\\pi \\frac{k m}{M}} \\cdot e^{-j 2\\pi \\frac{l n}{N}} $$\n代入原式：\n$$ F[k,l] = \\sum_{m=0}^{M-1}\\sum_{n=0}^{N-1} f[m,n] , e^{-j 2\\pi \\frac{k m}{M}} , e^{-j 2\\pi \\frac{l n}{N}} $$\n这就意味着可以先对 n 做求和，再对 m 做求和：\n$$ F[k,l] = \\sum_{m=0}^{M-1} \\left[ e^{-j 2\\pi \\frac{k m}{M}} \\left( \\sum_{n=0}^{N-1} f[m,n] , e^{-j 2\\pi \\frac{l n}{N}} \\right) \\right] $$\n这也就是说，可以拆分为先对行做 FFT，得到结果后再在列方向做一次 FFT。（也可以先列后行反过来，不影响结果）\n算法时间复杂度上，DFT 的时间复杂度为：\n$$ \\mathcal{O}(M^2 N^2) $$\n拆分为 2 个 1D FFT 后为：\n$$ \\mathcal{O}(M N \\log N + N M \\log M) = \\mathcal{O}(M N (\\log M + \\log N)) $$\n这里给出 2D 的 FFT 代码：\nimport numpy as np from fft1d import fft, ifft def fft2d(matrix): temp = np.array([fft(row) for row in matrix]) temp = np.array([fft(col) for col in temp.T]).T return temp def ifft2d(matrix): temp = np.array([ifft(row) for row in matrix]) temp = np.array([ifft(col) for col in temp.T]).T return temp if __name__ == \u0026#34;__main__\u0026#34;: x = np.array([ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12], [13,14,15,16] ], dtype=float) print(\u0026#34;x[i,j]:\u0026#34;) print(x) # 2D FFT X = fft2d(x) print(\u0026#34;\\n2D FFT X:\u0026#34;) print(np.round(X, 2)) # 2D IFFT x_rec = ifft2d(X) print(\u0026#34;\\n2D IFFT x_rec:\u0026#34;) print(np.round(x_rec.real, 2)) 结果如下：\nx[i,j]: [[ 1. 2. 3. 4.] [ 5. 6. 7. 8.] [ 9. 10. 11. 12.] [13. 14. 15. 16.]] 2D FFT X: [[136. +0.j -8. +8.j -8. +0.j -8. -8.j] [-32.+32.j 0. +0.j 0. +0.j 0. +0.j] [-32. +0.j 0. +0.j 0. +0.j 0. +0.j] [-32.-32.j 0. +0.j 0. +0.j 0. +0.j]] 2D IFFT x_rec: [[ 1. 2. 3. 4.] [ 5. 6. 7. 8.] [ 9. 10. 11. 12.] [13. 14. 15. 16.]] 4. 参考致谢 花了几天时间终于写完了，感觉得到了进化。\n个人感觉大量的科普视频和参考文章都局限于过多的打比方和举例子。实际上从第一性原理直接彻底了解反而是最简单的。\n按照杨振宁的话说：“当直觉与书本知识有冲突，是最好的学习机会，必须抓住，把本来的直觉错误想清楚，形成新的直觉”。\n特别感谢下列视频作者：\nDR_CAN1的傅里叶变换推导过程。 nksunmoon2的 FFT 过程讲解。 DR_CAN , 2018, 纯干货数学推导_傅里叶级数与傅里叶变换, https://www.bilibili.com/video/BV1Et411R78v\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nnksunmoon, 2022, 快速傅里叶变换原理, https://www.bilibili.com/video/BV1Ng411v7Dk\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://cronrpc.github.io/zh/posts/fourier-transform/","summary":"\u003ch2 id=\"1-傅里叶变换\"\u003e1. 傅里叶变换\u003c/h2\u003e\n\u003cp\u003e傅里叶变换起源于18世纪研究振动与热传导的问题。欧拉、达朗贝尔和伯努利提出用正弦波描述振动，奠定了思想基础。\u003c/p\u003e\n\u003cp\u003e19世纪初，法国数学家傅里叶在研究热传导时提出任何函数都可展开为正弦与余弦级数，这就是傅里叶级数，并逐渐发展为傅里叶变换。\u003c/p\u003e","title":"Fourier Transform"},{"content":"Stencil 介绍 Stencil 的概念和 Stencil Buffer 联系在一起。\n我们知道，屏幕有深度缓冲，在默认情况下，当正在渲染的点的距离大于深度缓冲里的值时，就会直接丢弃此时Pass。\nStencil Buffer 也是一个 Buffer，不同于深度缓冲有默认的大小对比行为，Stencil Buffer 需要我们手动约定处理方式。\n官方12有一些介绍，不过可能稍微有点抽象不好理解，这里我们从一个例子出发，来解释下可以做到什么。\nStencil Test 假如本来我们有一个Cube和一个正方形面片Quad，当Quad在Cube的前面的时候，Cube会被遮住一些部分。\n现在我们将Quad替换为下面的 Shader，这个 Shader 做了下列几件事：\nBlend Zero One 表示保持原有的颜色，这意味着渲染的物体将是透明的。 ZWrite Off 表示不改变深度缓冲 Stencil 内的内容就是模板测试，具体内容后面会再解释，这里只需要知道Comp Always表示永远通过，Pass Replace表示Pass后将 Stencil 缓冲区的值替换为Ref所表示的值。 Shader \u0026#34;Custom/Stencil/StencilFilter\u0026#34; { Properties { [IntRange] _StencilID (\u0026#34;Stencil ID\u0026#34;, Range(0, 255)) = 1 } SubShader { Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; \u0026#34;RenderPipeline\u0026#34; = \u0026#34;UniversalPipeline\u0026#34; \u0026#34;Queue\u0026#34; = \u0026#34;Geometry\u0026#34; } Blend Zero One ZWrite Off Stencil { Ref [_StencilID] Comp Always Pass Replace } Pass { } } } 现在Quad将是透明的，同时，它也改写了整个区域的Stencil Buffer的值。\n然后，我们将Cube的Shader也进行替换：\n我们只需要关注Stencil内的内容，这里Comp Equal的意思是，如果Ref的值等于Stencil Buffer就通过测试，继续后面的Pass，否则停止渲染。 Shader \u0026#34;Custom/Stencil/StencilTest\u0026#34; { Properties { [IntRange] _StencilID (\u0026#34;Stencil ID\u0026#34;, Range(0, 255)) = 0 [MainColor] _BaseColor(\u0026#34;Base Color\u0026#34;, Color) = (1, 1, 1, 1) [MainTexture] _BaseMap(\u0026#34;Base Map\u0026#34;, 2D) = \u0026#34;white\u0026#34; } SubShader { Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; \u0026#34;RenderPipeline\u0026#34; = \u0026#34;UniversalPipeline\u0026#34; \u0026#34;Queue\u0026#34; = \u0026#34;Geometry\u0026#34; } Stencil { Ref [_StencilID] Comp Equal } Pass { HLSLPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\u0026#34; struct Attributes { float4 positionOS : POSITION; float2 uv : TEXCOORD0; }; struct Varyings { float4 positionHCS : SV_POSITION; float2 uv : TEXCOORD0; }; TEXTURE2D(_BaseMap); SAMPLER(sampler_BaseMap); CBUFFER_START(UnityPerMaterial) half4 _BaseColor; float4 _BaseMap_ST; CBUFFER_END Varyings vert(Attributes IN) { Varyings OUT; OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz); OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap); return OUT; } half4 frag(Varyings IN) : SV_Target { half4 color = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv) * _BaseColor; return color; } ENDHLSL } } } 将Quad和Cube的_StencilID的值都改为相同的值，比如1。\n然后拖动Quad，会看到非常有意思的一幕。只有被Quad遮挡的区域，才会渲染Cube。\n如果我们有2个不同_StencilID的Cube，和2个不同_StencilID的Quad，它们可以各自显示符合自己ID的Cube，但是不会显示另一个Cube。\n这里稍微解释下发生了什么：\n由于整个屏幕每次渲染默认的Stencil Buffer的值是0，所以两个Cube在Quad没有覆盖到的地方都不会显示。 Quad渲染后改变了当前像素的Stencil Buffer的值，而Cube设置了Comp Equal，所以可以显示在改变了Stencil Buffer的区域。 渲染顺序 在上面的探讨中，可以意识到一个问题：Quad只有在Cube之前渲染，才能够先改变Stencil Buffer，然后渲染Cube。\n如果它们的渲染顺序也就是Queue都是相等的，那么可能会发生闪烁。\n可以将Quad的Queue设置为比Cube更小的值，此时就可以确保Quad在Cube之前进行渲染。\nCube不再会发生闪烁：\nStencil Test 语法介绍 可以参考官方文档2或者这篇中文文章3。\n核心语法如下：\nStencil { Ref \u0026lt;ref\u0026gt; ReadMask \u0026lt;readMask\u0026gt; WriteMask \u0026lt;writeMask\u0026gt; Comp \u0026lt;comparisonOperation\u0026gt; Pass \u0026lt;passOperation\u0026gt; Fail \u0026lt;failOperation\u0026gt; ZFail \u0026lt;zFailOperation\u0026gt; } 其中\u0026lt;ref\u0026gt;是参考值，它如何与Stencil Buffer对比取决于Comp。\nReadMask 是对比的时候的遮罩，同理 WriteMask 是写入的时候的遮罩。\nComp定义Ref与Stencil Buffer Value如何对比，默认是Always也就是总是Pass，Equal表示相等时Pass，还有Less/LEqual/Grater/NotEqual/GEual等等。\nPass定义的是Comp通过后对Stencil Buffer Value的操作，比如Keep表示保持Stencil Buffer的值，Replace表示用Ref的值替换掉Stencil Buffer的值，还有Zero/IncrSat/DecrSat/Invert/IncrWrap/DecrWrap。\nFail定义的是Comp失败后的操作，内容和Pass一样。\nZFail定义的是Comp通过，但是深度缓冲测试未通过的情况，内容还是和Pass一样。\n还可以单独定义正面和反面的Pass/Fail/ZFail，这里可以查看官方文档去了解。\n一个最简单的修改Stencil Buffer的代码：\nStencil { Ref 1 Comp Always Pass Replace } 一个最简单的测试Stencil Buffer的代码：\nStencil { Ref 1 Comp Equal } Renderer Objects feature 如果每增加一个Shader，我们就需要添加Stencil Buffer，然后设置_StencilID，那无疑会是一个非常麻烦的事情，这意味着我们需要修改很多材质。\n你也可以参考 impossible-geom-stencils4 了解如何使用 Renderer Objects feature 来设置Stencil。\n如图，场景中有3个Cube和2个Quad，其中紫色的Cube是半透明材质。\n先将2个Quad替换为前面的StencilFilter。\n创建2个新的Layer，分别命名Stencil Object 1和Stencil Object 2，给3个Cube分配上这2个Layer中的任意1个。\n然后找到Universal Renderer Data设置，取消掉这两层的渲染。\n添加一个Render Objects Feature，Filters中的Layer Mask选择Stencil Object 1/2，这里一共需要添加4个Render Objects Feature，对应2种Queue和2个Layer Mask。\n重点是在Override中，勾选Stencil，这样可以覆盖掉原有的Stencil设置，比如这里改为Equal同时设置Value为对应的值。\n还有一点就是Event插入时机，如果是Opaque应该对应选择After Rendering Opaques，Transparent要对应选择After Rendering Transparents。\n看一下效果：\n如果修改一下场景布局，取消相机渲染天空盒，给StencilFilter加上颜色，就可以有如下的Magic Cube：\nUnity, 2025, writing-shader-set-stencil, https://docs.unity3d.com/6000.2/Documentation/Manual/writing-shader-set-stencil.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUnity, 2025, SL-Stencil, https://docs.unity3d.com/6000.2/Documentation/Manual/SL-Stencil.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nlupeng0330, 2015, UnityShader实例09:Stencil Buffer\u0026amp;Stencil Test , https://blog.csdn.net/u011047171/article/details/46928463\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDaniel Ilett, 2022, impossible geom stencils, https://danielilett.com/2022-01-05-tut5-22-impossible-geom-stencils/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://cronrpc.github.io/zh/posts/stencil-buffer-and-stencil-test/","summary":"\u003ch2 id=\"stencil-介绍\"\u003eStencil 介绍\u003c/h2\u003e\n\u003cp\u003eStencil 的概念和 Stencil Buffer 联系在一起。\u003c/p\u003e\n\u003cp\u003e我们知道，屏幕有深度缓冲，在默认情况下，当正在渲染的点的距离大于深度缓冲里的值时，就会直接丢弃此时Pass。\u003c/p\u003e\n\u003cp\u003eStencil Buffer 也是一个 Buffer，不同于深度缓冲有默认的大小对比行为，Stencil Buffer 需要我们手动约定处理方式。\u003c/p\u003e","title":"Unity Stencil Buffer \u0026 Stencil Test"},{"content":"Worley Noise Worley Noise1（也称为 Voronoi noise 和 Cellular noise）是由 Steven Worley2 在 1996 年引入的一种噪声函数。\n它的样子看起来就是生物细胞的样子，由一个个 cell 构成，作者本身也是叫它“Cellular Texture”。\nWorley Noise 的生成算法是：将整个图像分为一个个小方格，每个小方格中会有1个特征点，每个像素点的数值，是它到周围单元格中特征点的距离的最小值。\n由于每个小方格只有1个特征点，每个像素只需要检查临近的9个小方格，一共只需要对比9个点来计算出它的值。\n这里有2个在游戏中的应用案例3，分别是龟裂的干旱地面和造型夸张的烟柱。\nShadertoy 在本次代码实现过程中，我主要学习自Suboptimal Engineer4和The Book of Shaders5，并在Shadertoy6上进行了具体的代码编写。\n同时，在iquilezles7这个网站有很多图形学相关的知识可以进行参考。\nGrid Code 进入 Shadertoy，输入下列的代码：\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec3 col = vec3(0.0); fragColor = vec4(col,1.0); } 此时显示纯黑色。\n将坐标变为正方形方格坐标，每个方格的范围在$[-0.5, +0.5]$之间。\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.y; uv = uv * 4.0; vec2 gird = floor(uv); vec2 coord = fract(uv) - 0.5; vec3 col = vec3(coord, 0); fragColor = vec4(col,1.0); } 根据距离每个方格边框的距离，来进行上色。\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.y; uv = uv * 4.0; vec2 gird = floor(uv); vec2 coord = fract(uv) - 0.5; float distanceGrid = 2.0 * max(abs(coord.x), abs(coord.y)); vec3 col = vec3(distanceGrid); fragColor = vec4(col,1.0); } 只在临近边界的地方进行上色，并添加颜色为红色。\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.y; uv = uv * 4.0; vec2 gird = floor(uv); vec2 coord = fract(uv) - 0.5; float distanceGrid = smoothstep(0.9, 1.0, 2.0 * max(abs(coord.x), abs(coord.y))); vec3 girdColor = vec3(1.0, 0, 0) * vec3(distanceGrid); vec3 col = girdColor; fragColor = vec4(col,1.0); } Cell Code 接下来做两件事：\n根据伪随机函数，确定每个方格的点的位置 计算当前像素到临近9个方格点的距离，取最小值 先绘制所有方格点，每个方格中只有1个点。\nvec2 random2( vec2 p ) { // add 0.5 to avoid vec2(0, 0) return (0, 0) return fract(sin(vec2(dot(p + 0.5, vec2(213.1,322.2)),dot(p + 0.5, vec2(513.1,312.2))))*51312.1234); } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.y; uv = uv * 4.0; vec2 gird = floor(uv); vec2 coord = fract(uv) - 0.5; // Gird Color float distanceGrid = smoothstep(0.9, 1.0, 2.0 * max(abs(coord.x), abs(coord.y))); vec3 girdColor = vec3(1.0, 0, 0) * vec3(distanceGrid); // Cell Color float distancePoint = 1.0; for (int i=-1; i\u0026lt;=1; i++) { for (int j=-1; j\u0026lt;=1; j++) { vec2 near = vec2(float(i), float(j)); vec2 point = near + 0.5 * sin(iTime + 6.2831 * random2(gird + near)); float currentDistance = length(coord - point); distancePoint = min(currentDistance, distancePoint); } } vec3 pointColor = vec3(smoothstep(0.90, 1.0, 1.0 - distancePoint)); vec3 col = girdColor + pointColor; fragColor = vec4(col,1.0); } 在有了距离后，只要根据距离显示颜色就可以了。\nvec2 random2( vec2 p ) { // add 0.5 to avoid vec2(0, 0) return (0, 0) return fract(sin(vec2(dot(p + 0.5, vec2(213.1,322.2)),dot(p + 0.5, vec2(513.1,312.2))))*51312.1234); } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.y; uv = uv * 4.0; vec2 gird = floor(uv); vec2 coord = fract(uv) - 0.5; // Gird Color float distanceGrid = smoothstep(0.95, 1.0, 2.0 * max(abs(coord.x), abs(coord.y))); vec3 girdColor = vec3(1.0, 0, 0) * vec3(distanceGrid); // Cell Color float distancePoint = 1.0; for (int i=-1; i\u0026lt;=1; i++) { for (int j=-1; j\u0026lt;=1; j++) { vec2 near = vec2(float(i), float(j)); vec2 point = near + 0.5 * sin(iTime + 6.2831 * random2(gird + near)); float currentDistance = length(coord - point); distancePoint = min(currentDistance, distancePoint); } } vec3 pointColor = vec3(smoothstep(0.95, 1.0, 1.0 - distancePoint)); vec3 distanceColor = vec3(smoothstep(0.2, 2.0, 1.7 - distancePoint)); vec3 col = girdColor + pointColor + distanceColor; fragColor = vec4(col,1.0); } 最后，如果移除辅助网格和中点，得到 Worley Noise 的图像。\nPalettes 最后通过渐变插值来上一点颜色8\nvec3 palette( in float t) { vec3 a = vec3(0.5, 0.5, 0.5); vec3 b = vec3(0.5, 0.5, 0.5); vec3 c = vec3(1.0, 1.0, 1.0); vec3 d = vec3(0.0, 0.1, 0.2); return a + b * cos( 6.283185 * ( c * t + d ) ); } vec2 random2( vec2 p ) { // add 0.5 to avoid vec2(0, 0) return (0, 0) return fract(sin(vec2(dot(p + 0.5, vec2(213.1,322.2)),dot(p + 0.5, vec2(513.1,312.2))))*51312.1234); } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.y; uv = uv * 4.0; vec2 gird = floor(uv); vec2 coord = fract(uv) - 0.5; // Gird Color float distanceGrid = smoothstep(0.95, 1.0, 2.0 * max(abs(coord.x), abs(coord.y))); vec3 girdColor = vec3(1.0, 0, 0) * vec3(distanceGrid); // Cell Color float distancePoint = 1.0; for (int i=-1; i\u0026lt;=1; i++) { for (int j=-1; j\u0026lt;=1; j++) { vec2 near = vec2(float(i), float(j)); vec2 point = near + 0.5 * sin(iTime + 6.2831 * random2(gird + near)); float currentDistance = length(coord - point); distancePoint = min(currentDistance, distancePoint); } } vec3 pointColor = vec3(smoothstep(0.95, 1.0, 1.0 - distancePoint)); vec3 distanceColor = vec3(palette(smoothstep(0.2, 2.0, 1.7 - distancePoint))); vec3 col = distanceColor; col += girdColor + pointColor; fragColor = vec4(col,1.0); } wikipedia, Worley noise, https://en.wikipedia.org/wiki/Worley_noise\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSteven Worley, (1996), A Cellular Texture Basis Function, https://cedric.cnam.fr/~cubaud/PROCEDURAL/worley.pdf\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPor Ryan Brucks, (2016) , Getting the Most Out of Noise in UE4, https://www.unrealengine.com/es-ES/tech-blog/getting-the-most-out-of-noise-in-ue4\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSuboptimal Engineer, (2023), What is Voronoi Noise? , https://www.youtube.com/watch?v=vcfIJ5Uu6Qw\u0026ab_channel=SuboptimalEngineer\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPatricio Gonzalez Vivo and Jen Lowe, The Book of Shaders, https://thebookofshaders.com/12/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nShadertoy, https://www.shadertoy.com/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\niquilezles, float small and random, https://iquilezles.org/articles/sfrand/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\niquilezles, palettes - 1999, https://iquilezles.org/articles/palettes/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://cronrpc.github.io/zh/posts/worley-noise-generator/","summary":"\u003ch2 id=\"worley-noise\"\u003eWorley Noise\u003c/h2\u003e\n\u003cp\u003eWorley Noise\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e（也称为 Voronoi noise 和 Cellular noise）是由 Steven Worley\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e 在 1996 年引入的一种噪声函数。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"worley noise\" loading=\"lazy\" src=\"/zh/posts/worley-noise-generator/worley-noise.png\"\u003e\u003c/p\u003e\n\u003cp\u003e它的样子看起来就是生物细胞的样子，由一个个 cell 构成，作者本身也是叫它“Cellular Texture”。\u003c/p\u003e","title":"Worley Noise / Voronoi Noise Generator"},{"content":"SDF 介绍 Signed Distance Field (SDF) Signed Distance Field（有符号距离场）1是一种用于表示形状的数学函数或数据结构。\n它在二维或三维空间中为每个点分配一个带符号的距离值，表示该点到最近表面（或边界）的距离，并用符号区分内外：\n正值：点位于形状外部，数值表示距离表面的最近距离。 负值：点位于形状内部，绝对值表示距离表面的最近距离。 零：点正好位于形状的表面上。 形式化定义，对于空间中的点 $x$，SDF 可以表示为：\n$$ f(x) = \\begin{cases} d(x, \\partial\\Omega), \u0026amp; \\text{if } x \\in \\Omega \\\\ -d(x, \\partial\\Omega), \u0026amp; \\text{if } x \\notin \\Omega \\\\ 0, \u0026amp; \\text{if } x \\in \\partial\\Omega \\end{cases} $$\n其中的$\\Omega$属于物体内，$\\partial\\Omega$表示边界，$d(x, \\partial\\Omega)$表示点$x$到边界的最小距离。\nGitHub 仓库 如果你想查看最终的生成SDF图片的代码，可以在GitHub仓库2获取：cronrpc/Signed-Distance-Field-2D-Generator\n应用 上面的说法可能非常抽象，我们看一些具体的应用实例。\n字体渲染（Valve 的 SDF 字体技术3），Unity的TMP字体就是使用了SDF技术。 光线追踪中的表面求交\n风格化阴影、云等\n凡是某种连续过渡的参数，都可以考虑使用SDF技术。\n2D SDF 生成算法 对于一张灰度图，白色部分表示物体，黑色是背景。如何生成它的SDF图呢？\n暴力求值法 一个最为简单的方式是，遍历算法。\n首先我们找出所有的边界集合。也就是当前像素是白色，而周围像素有黑色的点。 遍历所有的点，计算距离边界集合的最近距离。 根据本身的黑白，添加距离的正负号。 如果假设像素点的数目是$n$，那么复杂度是$O(n^2)$。\n# generator_sdf.py import sys import math from PIL import Image import numpy as np def generate_sdf(input_path, output_path): # 读取灰度图（0-255） img = Image.open(input_path).convert(\u0026#34;L\u0026#34;) w, h = img.size pixels = np.array(img) # Step 1: 找出边界集合 boundary_points = [] for y in range(h): for x in range(w): if pixels[y, x] \u0026gt; 127: # 白色 # 检查周围像素是否有黑色 neighbors = [ (nx, ny) for nx in (x - 1, x, x + 1) for ny in (y - 1, y, y + 1) if 0 \u0026lt;= nx \u0026lt; w and 0 \u0026lt;= ny \u0026lt; h and not (nx == x and ny == y) ] for nx, ny in neighbors: if pixels[ny, nx] \u0026lt;= 127: # 黑色 boundary_points.append((x, y)) break # Step 2 \u0026amp; 3: 计算SDF sdf = np.zeros((h, w), dtype=np.float32) for y in range(h): for x in range(w): min_dist = float(\u0026#34;inf\u0026#34;) for bx, by in boundary_points: dist = math.sqrt((x - bx) ** 2 + (y - by) ** 2) if dist \u0026lt; min_dist: min_dist = dist # 黑色取负值 if pixels[y, x] \u0026lt;= 127: min_dist = -min_dist sdf[y, x] = min_dist # 归一化到0-255 max_dist = np.max(np.abs(sdf)) sdf_normalized = ((sdf / max_dist) + 1) * 127.5 sdf_img = Image.fromarray(np.clip(sdf_normalized, 0, 255).astype(np.uint8)) sdf_img.save(output_path) print(f\u0026#34;SDF saved to {output_path}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) != 3: print(\u0026#34;Example: python generator_sdf.py test.png test_sdf.png\u0026#34;) sys.exit(1) generate_sdf(sys.argv[1], sys.argv[2]) 生成的结果：\n通过在PS中改变图片的显示阈值，可以观察到圆形的SDF变化：\n同理在正方形的SDF中，也可以观察效果。正方形的SDF的特点就是在内部时等高线是直角，在外部时等高线是圆弧。\n八邻域欧几里得近似距离 度量空间4（Metric Space）是数学中刻画“距离”这一概念的抽象框架。它由一个集合 $X$ 及其上的距离函数\n$$ d : X \\times X \\to \\mathbb{R} $$\n构成，并且这个距离函数必须满足以下四个条件：\n非负性：距离永远是非负数。\n恒等性：距离为零时，两点必须相同。\n对称性：从 $x$ 到 $y$ 的距离等于从 $y$ 到 $x$ 的距离。\n三角不等式：直接到达不应比绕路更远。\n$$ d(x, z) \\le d(x, y) + d(y, z) $$\n例如，在连续的二维平面中，欧几里得距离：\n$$ d(P, Q) = \\sqrt{(x_P - x_Q)^2 + (y_P - y_Q)^2} $$\n是一个典型的度量函数。\n下图的蓝色线条、红色线条、黄色线条都是表示同样的长度，而绿色是比它们都短的欧几里得距离。\n然而在数字图像处理或栅格地图中，我们的点是离散的像素格，距离计算可以直接用欧几里得公式，但这样需要大量平方根运算，代价较高。 为提高效率，常采用 八邻域欧几里得近似距离（8-neighborhood Euclidean approximation）：\n八邻域：指每个像素与其水平方向、垂直方向和对角线方向上最近的 8 个像素相邻。 在这种邻接关系下，可以用下式近似欧几里得距离： $$ d_{8}(p, q) \\approx \\max(\\Delta x, \\Delta y) + (\\sqrt{2} - 1) \\cdot \\min(\\Delta x, \\Delta y) $$\n其中 $\\Delta x = |x_p - x_q|$，$\\Delta y = |y_p - y_q|$。\n例如下图中的红色就是表示八邻域欧几里得近似距离，而蓝色直线就是欧几里得距离。\n这种方法避免了大量开方计算，同时在 8 邻域范围内与真实欧几里得距离的误差很小，因此常用于路径搜索（A*、Dijkstra）、距离变换、图像形态学等场景。\n8SSEDT 对这个算法的介绍参考自Lisapple 8SSEDT5。\n在上一小节中，我们已经介绍了八邻域欧几里得近似距离。实际上，对于图中的每个节点，其距离值可以用如下递推关系表示：\n$$ f(x, y) = \\min_{\\substack{dx, dy \\in {-1,0,1} \\ (dx, dy) \\neq (0,0)}} \\Big( f(x+dx, y+dy) + d(dx, dy) \\Big) $$\n其中，$d(dx, dy)$ 表示从邻居节点 $(x+dx, y+dy)$ 移动到节点 $(x, y)$ 的代价，通常取：\n$$ d(dx, dy) = \\begin{cases} 1, \u0026amp; \\text{若 } |dx| + |dy| = 1 \\quad (\\text{水平或垂直邻居})\\\\ \\sqrt{2}, \u0026amp; \\text{若 } |dx| + |dy| = 2 \\quad (\\text{对角邻居}) \\end{cases} $$\n这里，$dx$ 和 $dy$ 可以分别取 $-1, 0, 1$，但不能同时为零，这样才是邻居节点。\n如果给邻居节点进行标号：\n[#1][#2][#3] [#4][ x][#5] [#6][#7][#8] 对于任意两个点$x$和$y$之间的距离路径，只可能由下面4个组合中的1种构成，也就是说必然是其中之一的线性叠加：\n1,2,4 2,3,5 4,6,7 5,7,8 所以从左上角递推到右下角，就可以覆盖第1种$1,2,4$的可能，也就是说最多$4$次遍历整个图，就能确定所有点的值。\n当然，这里进行了一点优化，参考Signed Distance Fields6的实现，他选择了下列$4$个遍历路径：\n- - - \u0026gt; | [?][?][?] | [?][x][ ] v [ ][ ][ ] \u0026lt; - - - | [ ][ ][ ] | [ ][x][?] v [ ][ ][ ] \u0026lt; - - - ^ [ ][ ][ ] | [ ][x][?] | [?][?][?] - - - \u0026gt; ^ [ ][ ][ ] | [?][x][ ] | [ ][ ][ ] 这里直接给出Python的实现：\n准确来说下列代码的距离定义是欧几里得距离，并不是八邻域欧几里得近似距离。 只是借鉴了移动方向为8个方向 import sys import os import numpy as np from PIL import Image INF = 9999 def dist_sq(dx, dy): return dx*dx + dy*dy def compare(grid, p, x, y, ox, oy, width, height): nx = x + ox ny = y + oy if 0 \u0026lt;= nx \u0026lt; width and 0 \u0026lt;= ny \u0026lt; height: other_dx, other_dy = grid[ny, nx] else: other_dx, other_dy = INF, INF other_dx += ox other_dy += oy if dist_sq(other_dx, other_dy) \u0026lt; dist_sq(*p): p = (other_dx, other_dy) return p def generate_sdf(grid): height, width, _ = grid.shape # Pass 0 for y in range(height): for x in range(width): p = tuple(grid[y, x]) p = compare(grid, p, x, y, -1, 0, width, height) p = compare(grid, p, x, y, 0, -1, width, height) p = compare(grid, p, x, y, -1, -1, width, height) p = compare(grid, p, x, y, 1, -1, width, height) grid[y, x] = p for x in range(width-1, -1, -1): p = tuple(grid[y, x]) p = compare(grid, p, x, y, 1, 0, width, height) grid[y, x] = p # Pass 1 for y in range(height-1, -1, -1): for x in range(width-1, -1, -1): p = tuple(grid[y, x]) p = compare(grid, p, x, y, 1, 0, width, height) p = compare(grid, p, x, y, 0, 1, width, height) p = compare(grid, p, x, y, -1, 1, width, height) p = compare(grid, p, x, y, 1, 1, width, height) grid[y, x] = p for x in range(width): p = tuple(grid[y, x]) p = compare(grid, p, x, y, -1, 0, width, height) grid[y, x] = p def load_image_binary(path, threshold=128): im = Image.open(path).convert(\u0026#39;L\u0026#39;) arr = np.array(im, dtype=np.uint8) inside = arr \u0026lt; threshold return inside, im def save_signed_sdf_image(signed, out_path): # 归一化到0-255，128为边界 max_dist = np.max(np.abs(signed)) if max_dist == 0: # 防止除以0 sdf_normalized = np.full_like(signed, 128.0) else: sdf_normalized = ((signed / max_dist) + 1.0) * 128.0 sdf_normalized = np.clip(sdf_normalized, 0, 255).astype(np.uint8) out = Image.fromarray(sdf_normalized, mode=\u0026#39;L\u0026#39;) out.save(out_path) def main(): if len(sys.argv) \u0026lt; 2: print(\u0026#34;Usage: python 8ssedt.py input.png\u0026#34;) sys.exit(1) in_path = sys.argv[1] if not os.path.exists(in_path): print(\u0026#34;File not found:\u0026#34;, in_path) sys.exit(1) inside, im = load_image_binary(in_path) h, w = inside.shape empty = (INF, INF) zero = (0, 0) # two grids: inside distances and outside distances grid1 = np.zeros((h, w, 2), dtype=int) grid2 = np.zeros((h, w, 2), dtype=int) for y in range(h): for x in range(w): if inside[y, x]: grid1[y, x] = zero grid2[y, x] = empty else: grid1[y, x] = empty grid2[y, x] = zero generate_sdf(grid1) generate_sdf(grid2) dist1 = np.sqrt(grid1[:, :, 0]**2 + grid1[:, :, 1]**2) dist2 = np.sqrt(grid2[:, :, 0]**2 + grid2[:, :, 1]**2) signed = dist1 - dist2 base, ext = os.path.splitext(in_path) out_path = base + \u0026#34;_8ssedt.png\u0026#34; save_signed_sdf_image(signed, out_path) print(\u0026#34;Saved:\u0026#34;, out_path) if __name__ == \u0026#34;__main__\u0026#34;: main() 我们用它实验的这张原图来看看效果：\n在运行我们的脚本后，得到：\n放入PS中，查看不同阈值下的效果：\nCorrect 8SSEDT 参考7，他解决的问题是，对于2值的黑白图来说，邻近边界的点，距离边界的距离实质上应该只有半个像素。\n考虑到这半个像素的差别，会导致在接近边界的地方有一些误差，解决方法就是旁边的点是边界的时候，距离就只加一半的大小。\nimport sys import os import math import numpy as np from PIL import Image FIX = True INF = 9999 def dist_sq(dx, dy): return dx*dx + dy*dy def compare(grid, p, x, y, ox, oy, width, height): nx = x + ox ny = y + oy if 0 \u0026lt;= nx \u0026lt; width and 0 \u0026lt;= ny \u0026lt; height: other_dx, other_dy = grid[ny, nx] else: other_dx, other_dy = INF, INF if FIX: if other_dx != 0 or other_dy != 0: # 对应 other.DistSq()!=0 ox *= 2 oy *= 2 other_dx += ox other_dy += oy if dist_sq(other_dx, other_dy) \u0026lt; dist_sq(*p): p = (other_dx, other_dy) return p def generate_sdf(grid): height, width, _ = grid.shape # Pass 0 for y in range(height): for x in range(width): p = tuple(grid[y, x]) p = compare(grid, p, x, y, -1, 0, width, height) p = compare(grid, p, x, y, 0, -1, width, height) p = compare(grid, p, x, y, -1, -1, width, height) p = compare(grid, p, x, y, 1, -1, width, height) grid[y, x] = p for x in range(width-1, -1, -1): p = tuple(grid[y, x]) p = compare(grid, p, x, y, 1, 0, width, height) grid[y, x] = p # Pass 1 for y in range(height-1, -1, -1): for x in range(width-1, -1, -1): p = tuple(grid[y, x]) p = compare(grid, p, x, y, 1, 0, width, height) p = compare(grid, p, x, y, 0, 1, width, height) p = compare(grid, p, x, y, -1, 1, width, height) p = compare(grid, p, x, y, 1, 1, width, height) grid[y, x] = p for x in range(width): p = tuple(grid[y, x]) p = compare(grid, p, x, y, -1, 0, width, height) grid[y, x] = p def load_image_binary(path, threshold=128): im = Image.open(path).convert(\u0026#39;L\u0026#39;) arr = np.array(im, dtype=np.uint8) inside = arr \u0026lt; threshold return inside, im def save_signed_sdf_image(signed, out_path): # 归一化到0-255，128为边界 max_dist = np.max(np.abs(signed)) if max_dist == 0: # 防止除以0 sdf_normalized = np.full_like(signed, 128.0) else: sdf_normalized = ((signed / max_dist) + 1.0) * 128.0 sdf_normalized = np.clip(sdf_normalized, 0, 255).astype(np.uint8) out = Image.fromarray(sdf_normalized, mode=\u0026#39;L\u0026#39;) out.save(out_path) def main(): if len(sys.argv) \u0026lt; 2: print(\u0026#34;Usage: python 8ssedt.py input.png\u0026#34;) sys.exit(1) in_path = sys.argv[1] if not os.path.exists(in_path): print(\u0026#34;File not found:\u0026#34;, in_path) sys.exit(1) inside, im = load_image_binary(in_path) h, w = inside.shape empty = (INF, INF) zero = (0, 0) # two grids: inside distances and outside distances grid1 = np.zeros((h, w, 2), dtype=int) grid2 = np.zeros((h, w, 2), dtype=int) for y in range(h): for x in range(w): if inside[y, x]: grid1[y, x] = zero grid2[y, x] = empty else: grid1[y, x] = empty grid2[y, x] = zero generate_sdf(grid1) generate_sdf(grid2) dist1 = np.sqrt(grid1[:, :, 0]**2 + grid1[:, :, 1]**2) dist2 = np.sqrt(grid2[:, :, 0]**2 + grid2[:, :, 1]**2) if FIX: signed = 0.5 * (dist1 - dist2) else: signed = dist1 - dist2 base, ext = os.path.splitext(in_path) out_path = base + \u0026#34;_8ssedt_correct.png\u0026#34; save_signed_sdf_image(signed, out_path) print(\u0026#34;Saved:\u0026#34;, out_path) if __name__ == \u0026#34;__main__\u0026#34;: main() 从效果上看，几乎是和之前一样：\n但是从阈值角度来看，会稍微平滑一些，观察接近地方的值就知道了。\n修正后的结果：\n原来的结果：\n为什么还是用欧几里得距离？ 用公式：\n$$ d_8(p,q) = \\max(\\Delta x,\\Delta y) + (\\sqrt{2} - 1) \\cdot \\min(\\Delta x,\\Delta y) $$\n如果取两个点：$(1,4)$ 和 $(3,3)$\n计算 $d_8$\n$d_8(1,4) = 4 + (\\sqrt{2} - 1) \\cdot 1 \\approx 4 + 0.4142 = 4.4142$\n$d_8(3,3) = 3 + (\\sqrt{2} - 1) \\cdot 3 \\approx 3 + 1.2426 = 4.2426$\n⇒ $d_8(1,4) \u0026gt; d_8(3,3)$\n计算欧几里得距离\n$d_E(1,4) = \\sqrt{1^2 + 4^2} = \\sqrt{17} \\approx 4.1231$\n$d_E(3,3) = \\sqrt{3^2 + 3^2} = \\sqrt{18} \\approx 4.2426$\n⇒ $d_E(1,4) \u0026lt; d_E(3,3)$\n这个反例说明：$d_8$ 的排序不一定和欧几里得距离的排序一致，因此这里只是借鉴了八邻域的位移，但是两个点之间的距离还是按照欧几里得距离来计算。\nscipy.ndimage 库 前面用到的算法用Python写的还是太慢了，尤其是循环嵌套，在2048x2048开始速度会比较慢。\nscipy的图像处理底层采用C++来编写，速度会快非常多。\n下面代码的scale采用8（后面会说为什么不要使用normalize，而是用固定比例的缩放），同时输出采用16bit（而不是8bit）的灰度图。\nimport sys import os import numpy as np from PIL import Image from scipy import ndimage scale = 8 def load_image_binary(path, threshold=128): im = Image.open(path).convert(\u0026#39;L\u0026#39;) arr = np.array(im, dtype=np.uint8) inside = arr \u0026lt; threshold return inside def save_sdf_16bit(signed, out_path): # 直接转 uint16 保存，不做归一化 signed = signed * scale + 32767.5 signed_uint16 = np.clip(signed, 0, 65535).astype(np.uint16) out = Image.fromarray(signed_uint16, mode=\u0026#39;I;16\u0026#39;) out.save(out_path) def fast_signed_sdf(mask): dist_inside = ndimage.distance_transform_edt(mask) dist_outside = ndimage.distance_transform_edt(~mask) return dist_outside - dist_inside # inside 正，outside 负 def main(): if len(sys.argv) \u0026lt; 2: print(\u0026#34;Usage: python fast_sdf.py input1.png [input2.png ...]\u0026#34;) sys.exit(1) for in_path in sys.argv[1:]: if not os.path.exists(in_path): print(\u0026#34;File not found:\u0026#34;, in_path) continue inside = load_image_binary(in_path) signed = fast_signed_sdf(inside) base, _ = os.path.splitext(in_path) out_path = base + \u0026#34;_sdf16.png\u0026#34; save_sdf_16bit(signed, out_path) print(f\u0026#34;Saved SDF to {out_path}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 16bit 和 scale 前面使用了归一化距离的方式，但是如果希望合成多张图片，需要将距离的单位统一（因为需要在两张图片之间进行插值）。\n第二，如果图片尺寸非常大（2048），那么8bit只有256大小，就不够表示所有距离了，为了避免距离截断导致效果不好，采用16bit的png来存储距离。\n2048x2048大小的图片，两点间的最大距离是$2048*1.414=2,896$，同时16bit可以表示的最大范围是+-32767，所以可以选择$scale=8$或者$10$来表示。\nscale = 10 # 缩放到 0–65535，32767.5 为边界 unsigned = signed * scale + 32767.5 unsigned = np.clip(unsigned, 0, 65535).astype(np.uint16) 合成算法 怎么合成图片，取决于我们到底想实现什么样的效果。\n比如如果是想实现一个 subtraction 的效果，是不是直接把距离做减法就可以了呢？\n这种做法确实可以实现在中点处表现为减法，但是最左侧和左右侧的含义实际上是不明确的。\n# 布尔运算 def sdf_union(d1, d2): return np.minimum(d1, d2) # 并集 def sdf_intersection(d1, d2): return np.maximum(d1, d2) # 交集 def sdf_subtraction(d1, d2): return np.maximum(d1, -d2) # A 减 B 类似上面代码的合并的实际含义是：当处在阈值中点的时候，表现为并、交或者减法。\n插值思路 在游戏中，实质上追求的是这样一个过程，假如有两张图片a和b，我们希望在阈值最大的时候图片就是a的图案，阈值最小的时候图片就是b的图案。\n如果是三张图片，那就是最大值是a的图案，中间时就是b的图案，最小值时就是c的图案，以此类推。\n这里还需要限制一个条件，那就是它们必须是完全包含的关系，也就是$c \\supset b \\supset a$，只有这样才可能实现这个过程。\n对于图片a和b，由于包含关系，物体a上的任意一个像素，在a和b中的距离值都应该是正数，也就是在物体内部。\n对于$b-a$上的一个点$x$，在a中一定是负数$x_a$（外侧），在b中是正数$x_b$。所以$x$这个点在最终图像上的值$x_{final}$，实际上就应该是$x$从$x_b$插值到$x_a$过程中，$x=0$时刻对应的阈值的大小。\n比如，如果$x$在${sdf}_a$的值是$-3$，在${sdf}_b$的值是$3$。\n那么${x}_{final}$的大小在8bit灰度图下就应该是128，这样刚好在阈值128以下都能点亮这个像素。\n所以，核心的思路就是找对应的0点。\n蒙特卡洛插值法 这里参考了这篇文章8的算法，通过采样方式来寻找0点。\n注意，在Python下这种嵌套循环运行速度是非常慢的，超过2048尺寸的图片不适合用纯Python来写。\nimport sys import numpy as np from PIL import Image if len(sys.argv) != 3: print(\u0026#34;用法: python compose2.py a.png b.png\u0026#34;) sys.exit(1) # 读取 16bit 灰度图 def load_16bit_gray(path): img = Image.open(path) arr = np.array(img, dtype=np.uint16) return arr sdf1 = load_16bit_gray(sys.argv[1]) sdf2 = load_16bit_gray(sys.argv[2]) # 检查尺寸一致 if sdf1.shape != sdf2.shape: raise ValueError(\u0026#34;两张输入图片的尺寸必须相同\u0026#34;) height, width = sdf1.shape output = np.zeros((height, width), dtype=np.uint16) THRESHOLD = 32768 # 16bit 对应 0.5 灰度 MAX_VAL = 65535 STEPS = 16 for y in range(height): for x in range(width): t1 = sdf1[y, x] t2 = sdf2[y, x] if t1 \u0026lt; THRESHOLD and t2 \u0026lt; THRESHOLD: result = 0 elif t1 \u0026gt; THRESHOLD and t2 \u0026gt; THRESHOLD: result = MAX_VAL else: # 两张图片之间插值 result = 0 for i in range(STEPS): weight = i / STEPS interp = (1 - weight) * t1 + weight * t2 result += 0 if interp \u0026lt; THRESHOLD else MAX_VAL result //= STEPS output[y, x] = np.clip(result, 0, MAX_VAL) # 保存 16bit PNG out_img = Image.fromarray(output, mode=\u0026#39;I;16\u0026#39;) out_img.save(\u0026#34;output.png\u0026#34;) print(\u0026#34;合成完成: output.png\u0026#34;) 最终的算法 插值这个过程完全可以并行处理，首先每个像素之间就毫无关联，其次每个图片之间进行插值其实也没有关联。\n使用numpy来进行并行化处理，numpy底层是c++模块，速度非常快。\n这里采样点为256个对应灰度图范围，保存为8bit的灰度图（这里没必要16bit）。\nimport sys import numpy as np from PIL import Image U8 = True if len(sys.argv) \u0026lt; 3: print(\u0026#34;用法: python compose.py img1.png img2.png [img3.png ...]\u0026#34;) sys.exit(1) def load_16bit_gray(path): img = Image.open(path) arr = np.array(img, dtype=np.uint16) return arr # 读取所有图 images = [load_16bit_gray(path) for path in sys.argv[1:]] arr = np.stack(images, axis=0) # shape: (N, H, W) if not np.all([img.shape == arr[0].shape for img in images]): raise ValueError(\u0026#34;所有输入图片的尺寸必须相同\u0026#34;) THRESHOLD = 32768 MAX_VAL = 65535 N, H, W = arr.shape # 全局 mask all_below = np.all(arr \u0026lt; THRESHOLD, axis=0) all_above = np.all(arr \u0026gt; THRESHOLD, axis=0) output = np.zeros((H, W), dtype=np.float64) output[all_below] = 0 output[all_above] = MAX_VAL # 混合部分 mask mix_mask = ~(all_below | all_above) # 取混合部分像素 mix_pixels = arr[:, mix_mask].astype(np.float64) # shape: (N, M) M = 混合像素个数 M = mix_pixels.shape[1] # 256 个采样权重 samples = 256 weights = np.linspace(0, 1, samples, endpoint=False) # 每个采样点属于哪两个图之间 intervals = np.floor(weights * (N - 1)).astype(int) # shape: (samples,) local_w = (weights * (N - 1)) - intervals # shape: (samples,) # 插值批量计算 interp_results = np.zeros((samples, M), dtype=np.float64) for k in range(samples): i1 = intervals[k] i2 = i1 + 1 val = (1 - local_w[k]) * mix_pixels[i1] + local_w[k] * mix_pixels[i2] interp_results[k] = (val \u0026gt;= THRESHOLD) * MAX_VAL # 平均 res = np.mean(interp_results, axis=0) # 回写结果 output[mix_mask] = res if U8: # 转为浮点数，映射到 0~255 output_float = output.astype(np.float32) output_scaled = output_float / 65535.0 * 255.0 output_uint8 = np.clip(np.floor(output_scaled + 0.5), 0, 255).astype(np.uint8) # 保存 8 位灰度图 out_img = Image.fromarray(output_uint8, mode=\u0026#39;L\u0026#39;) out_img.save(\u0026#34;output8.png\u0026#34;) print(f\u0026#34;合成完成: output8.png，合并了 {N} 张图片\u0026#34;) else: output = np.clip(output, 0, MAX_VAL).astype(np.uint16) out_img = Image.fromarray(output, mode=\u0026#39;I;16\u0026#39;) out_img.save(\u0026#34;output16.png\u0026#34;) print(f\u0026#34;合成完成: output16.png，合并了 {N} 张图片\u0026#34;) 效果：\n原始图片：\n生成的sdf如图，这里因为scale的关系，看起来都比较接近灰色。\n合成sdf：\nwikipedia, Signed distance function, https://en.wikipedia.org/wiki/Signed_distance_function\u0026#160;\u0026#x21a9;\u0026#xfe0e;\ncronrpc, (2025), Signed Distance Field 2D Generator, https://github.com/cronrpc/Signed-Distance-Field-2D-Generator\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChris Green. Valve. (2007). Improved Alpha-Tested Magnification for Vector Textures and Special Effects, https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMetric Space, https://en.wikipedia.org/wiki/Metric_space\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLisapple, (2017), 8SSEDT , GitHub, https://github.com/Lisapple/8SSEDT\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRichard Mitton, (2009), Signed Distance Fields, http://www.codersnotes.com/notes/signed-distance-fields/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nfarteryhr, Correct 8SSEDT, https://replit.com/@farteryhr/Correct8SSEDT#main.cpp\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n蛋白胨, Unity 卡通渲染 程序化天空盒, https://zhuanlan.zhihu.com/p/540692272\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://cronrpc.github.io/zh/posts/signed-distance-field/","summary":"\u003ch2 id=\"sdf-介绍\"\u003eSDF 介绍\u003c/h2\u003e\n\u003ch3 id=\"signed-distance-field-sdf\"\u003eSigned Distance Field (SDF)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eSigned Distance Field\u003c/strong\u003e（有符号距离场）\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e是一种用于表示形状的数学函数或数据结构。\u003cbr\u003e\n它在二维或三维空间中为每个点分配一个\u003cstrong\u003e带符号的距离值\u003c/strong\u003e，表示该点到最近表面（或边界）的距离，并用符号区分内外：\u003c/p\u003e","title":"有符号距离场(SDF)"},{"content":"Perlin Noise 介绍 Perlin 噪声（Perlin Noise）是由 Ken Perlin 在 1983 年为电影《Tron》开发的一种平滑伪随机噪声算法1。它能够生成具有自然纹理的随机模式，广泛用于计算机图形学中模拟云彩、地形、火焰、木纹、水流等自然现象2。\n与普通白噪声不同，Perlin 噪声具有空间相关性：相邻采样点的值变化平滑，没有突兀的跳变。这种平滑特性使得它生成的纹理更像自然界的连续变化。\n我的世界就采用 Perlin Noise 来作为生成无限世界地图的基础算法。\n噪声类型 1D 均匀白噪声 1D 均匀白噪声 就是一维的、服从均匀分布的白噪声信号。\nimport numpy as np import matplotlib.pyplot as plt def sample_random_points(num_points): # 采样器函数，返回num_points个0~1之间的随机数 return np.random.rand(num_points) def draw_random_strip_image_from_samples(rand_1d, width, height, filename, thickness=1): num_points = len(rand_1d) cols_per_point = width // num_points rand_pos = (rand_1d * (height - 1)).astype(int) img = np.zeros((height, width)) for i, row in enumerate(rand_pos): start_row = max(row - thickness, 0) end_row = min(row + thickness + 1, height) start_col = i * cols_per_point end_col = start_col + cols_per_point img[start_row:end_row, start_col:end_col] = 1 plt.imshow(img, cmap=\u0026#39;gray\u0026#39;, origin=\u0026#39;lower\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.show() plt.imsave(filename, img, cmap=\u0026#39;gray\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: rand_noise = sample_random_points(512) draw_random_strip_image_from_samples(rand_noise, 1024, 512, \u0026#34;random_noise_1d.png\u0026#34;) 对于一维随机噪声来说，生成的随机点之间是没有任何关联的。\n如果采用Perlin Noise，得到的是连续而光滑的曲线。\n2D 均匀白噪声 如果我们随机生成一张均匀分布的噪声图，结果就是均匀白噪声，它们每个点和相邻的点之间是没有任何联系的。\nimport numpy as np import matplotlib.pyplot as plt # 生成 512x512 的随机浮点灰度图，值范围0~1 noise = np.random.rand(512, 512) plt.imshow(noise, cmap=\u0026#39;gray\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.imsave(\u0026#39;random_noise.png\u0026#39;, noise, cmap=\u0026#39;gray\u0026#39;) 完全随机的噪声：\n而 Perlin Noise 相邻点直接是有关联的，相邻点的数值上要求接近而且平滑。\n高斯白噪声 import numpy as np import matplotlib.pyplot as plt # 生成512x512的高斯白噪声，均值0.5，标准差0.1 noise = np.random.normal(loc=0.5, scale=0.1, size=(512, 512)) # 将值裁剪到0~1范围内，防止显示异常 noise = np.clip(noise, 0, 1) plt.imshow(noise, cmap=\u0026#39;gray\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.imsave(\u0026#39;gaussian_white_noise_2d.png\u0026#39;, noise, cmap=\u0026#39;gray\u0026#39;) plt.show() 由于非均匀分布，看起来会比白噪声更加柔和一点。\n高斯分布在一维上看起来会更加明显，因为有一个明显的中心带，集中了绝大多数点。\n1D Perlin Noise 如果我们需要理解 Perlin Noise 中分型相关的概念，我们需要先理解一下Fade、周期性和频率倍率的概念3。\nFade 在已知一系列点的数值的情况下，如果希望求中间的点的数值，可以通过线性插值产生折线，通过 Cosine 插值产生平滑的曲线。\n余弦插值可以用下列公式，\n$$ x = x1 + (x2-x1) * (1 - cos(\\pi \\alpha)) / 2 $$\n不同的插值方法的目的，就是在过渡处产生平滑的曲线而不是折线。除了余弦函数，还可以用三次函数、五次函数等等插值方法。\n这种把线性插值，转化为平滑插值，就叫 Fade 。\nPerlin 在改进型的噪声生成算法中采用的 Fade 函数是，\n$$ t = 6 t^5 - 15 t^4 + 10 t^3 $$\nOctaves 如果将采样频率不断翻倍，就可以获得不断减半周期的函数。由于音阶每个八度之间就是频率翻倍的关系，所以这里也叫做 Octaves 。\n将不同周期的噪声按照某种权重进行混合，就构成了 Perlin Noise 。\n通常将周期不断翻倍，同时将权重不断减半。这里有一种分型的概念。\n2D Perlin Noise Generator 算法 Ken Perlin 在他的网站上公布了 Perlin Noise 改进版的实现4。\nPerlin 噪声是一种基于网格的渐进式噪声函数，常用于生成自然感的纹理、地形等。二维版本的实现过程如下：\n1. 网格划分 将二维空间划分成一个规则的整数格点网格，每个格点都关联一个随机梯度向量（通常是单位向量，方向均匀分布）。\n2. 计算插值点的相对位置 给定采样点 $(x, y)$，先确定它所在的格点单元，即计算格点左下角的整数坐标 $(X, Y)$，\n$$ X = \\lfloor x \\rfloor, \\quad Y = \\lfloor y \\rfloor $$\n计算采样点相对于左下格点的局部坐标，\n$$ x_{rel} = x - X, \\quad y_{rel} = y - Y $$\n3. 计算格点梯度与距离向量的点积 对于这个单元的4个角（格点），\n$$ (X, Y), (X+1, Y), (X, Y+1), (X+1, Y+1) $$\n分别取出每个格点对应的梯度向量 $\\vec{g}$，计算梯度向量与采样点到该格点的距离向量 $\\vec{d}$ 的点积，\n$$ \\text{dot} = \\vec{g} \\cdot \\vec{d} $$\n4. 插值平滑 对上述4个点积结果，使用平滑插值函数（如 Ken Perlin 提出的 fade 函数）沿 x 和 y 方向进行双线性插值，\n$$ u = \\text{fade}(x_{rel}), \\quad v = \\text{fade}(y_{rel}) $$\n5. 输出噪声值 插值后的结果就是采样点 $(x,y)$ 的噪声值，通常范围大约在 $[-1, 1]$。\nPython Code 这里给出实现 2D Perlin Noise 算法的 Python 代码。\nimport numpy as np import matplotlib.pyplot as plt permutation = np.array([ 151,160,137,91,90,15, 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23, 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33, 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166, 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244, 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196, 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123, 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42, 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9, 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228, 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107, 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254, 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ], dtype=np.uint16) p = np.tile(permutation, 2) def grad(hash:int, x:float, y:float)-\u0026gt;float: grad_vectors = np.array([ [1, 1], [-1, 1], [1, -1], [-1, -1], [1, 0], [-1, 0], [0, 1], [0, -1] ]) # 归一化梯度向量 grad_vectors = grad_vectors / np.linalg.norm(grad_vectors, axis=1)[:, None] g = grad_vectors[hash % 8] return np.dot(g, [x, y]) def lerp(t: float, a: float, b: float)-\u0026gt;float: return a + t * (b - a) def fade(t: float)-\u0026gt;float: return t * t * t * (t * (t * 6 - 15) + 10) def get_noise(x:float, y:float): X = int(np.floor(x)) \u0026amp; 255 Y = int(np.floor(y)) \u0026amp; 255 x = x % 1 y = y % 1 u = fade(x) v = fade(y) ## 这里其实只要保证hash唯一就可以了 x1 = p[p[X] + Y] x2 = p[p[X+1] + Y] x3 = p[p[X] + Y + 1] x4 = p[p[X+1] + Y + 1] ## x3 x4 ## x1 x2 ## vector 方向都是从整数点 指向 噪声采样点 return lerp(v, lerp(u, grad(x1, x, y), grad(x2, x - 1, y)), lerp(u, grad(x3, x, y - 1), grad(x4, x - 1, y - 1))) def get_perlin_noise(width=256, height=256, scale=8.0, octaves=1, persistence=0.5, lacunarity=2.0): noise_arr = np.zeros((height, width), dtype=np.float32) for i in range(height): for j in range(width): for k in range(octaves): x = (j / width) * scale * (lacunarity ** k) y = (i / height) * scale * (lacunarity ** k) noise_arr[i, j] += (persistence ** k) * get_noise(x, y) return noise_arr fig, axs = plt.subplots(2, 2, figsize=(10, 10)) for octave_count, ax in zip(range(1, 5), axs.flatten()): noise_arr = get_perlin_noise(width=256, height=256, scale=8.0, octaves=octave_count) # 可选将范围变为 0~1 noise_arr = (noise_arr - noise_arr.min()) / (noise_arr.max() - noise_arr.min()) ax.imshow(noise_arr, cmap=\u0026#39;gray\u0026#39;) ax.set_title(f\u0026#39;octaves = {octave_count}\u0026#39;, fontsize=14) ax.axis(\u0026#39;off\u0026#39;) plt.tight_layout() plt.savefig(\u0026#39;perlin_noise_octaves_1_to_4.png\u0026#39;) 梯度值如何改进 使用固定梯度值而不是 Hash 完全均匀随机产生的梯度值，是避免导致方向性偏差，影响视觉自然度5。\n在原版中，梯度值是均匀分布在球面上，但是立方体并不是球面均匀的，沿着坐标轴方向会缩短，沿着对角线方向会拉长。\n这种方向上的不对称，容易导致一种零星的聚集效应：当一些彼此接近、方向几乎与坐标轴平行的梯度碰巧朝同一个方向排列时，就会在这些区域出现异常偏高的数值。\n所以 Perlin 在改进论文中建议选择：\n$$ (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1) $$\n同时为了避免除以 12 的开销，他将梯度方向补齐到 16 个，额外添加了 $(1,1,0),(-1,1,0),(0,-1,1),(0,-1,-1)$。\n本文参考了这个实现方式，使用的是平面8个方向的梯度，并且都进行了长度的归一化。\n如果是一维的 Perlin Noise，可以不进行归一化来增加波动。一维的 Perlin Noise 可以视作在二维的 Perlin Noise 沿着晶格画一条线，此时不在线上的晶格的权重都是0，和一维的 Perlin Noise 没有区别。在这种情况下，梯度值在水平方向上的投影就不是唯一的1， 斜边的投影大小是 $ \\frac{\\sqrt{2}}{2} $。\nFade 函数的改进 Perlin5 在论文中提出的改进就是替换 Fade 函数为二阶平滑的函数，也就是我上面所用的函数。\n原因是，如果二阶导数不是平滑的话，当它用于做表面替换的时候，能够看出非常明显的方块样式。\n所以最好遵循以下原则：\n在 0 和 1 的时候，导数应该为 0，使得其尽可能平滑过渡。甚至高阶导也可以为 0。 $ f(0) = 0 $ $ f(1) = 1 $ 应用举例 Python Noise 库 实际使用过程中，我们完全不需要编写 Perlin Noise 的代码。而是使用 Python Noise 库就可以直接生成 Perlin Noise 。\nimport numpy as np import matplotlib.pyplot as plt from noise import pnoise2 width, height = 512, 512 scale = 64.0 # 控制噪声“拉伸”程度，数值越大变化越缓慢 octaves = 6 persistence = 0.5 lacunarity = 2.0 noise = np.zeros((height, width)) for y in range(height): for x in range(width): nx = x / scale ny = y / scale noise[y][x] = pnoise2(nx, ny, octaves=octaves, persistence=persistence, lacunarity=lacunarity, repeatx=1024, repeaty=1024, base=0) # Perlin噪声默认范围大致在[-1,1]，归一化到[0,1] noise = (noise - noise.min()) / (noise.max() - noise.min()) plt.imshow(noise, cmap=\u0026#39;gray\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.imsave(\u0026#39;perlin_noise_2d_lib.png\u0026#39;, noise, cmap=\u0026#39;gray\u0026#39;) plt.show() 由于进行了优化，它的生成速度非常快：\n云层 用 Perlin Noise 模拟简单云层纹理。\n模拟云层边缘的消散效果\n模拟中心的高亮，因此大于阈值部分不动，只在某个范围内进行下列的操作。\n$$ \\text{Intensity} = max(\\text{Intensity} - 40, 0) $$\nimport numpy as np from PIL import Image # 读灰度图，保持 0~255 整数 img = Image.open(\u0026#39;perlin_noise_2d_lib.png\u0026#39;).convert(\u0026#39;L\u0026#39;) arr = np.array(img).astype(np.int32) # 0~255 height, width = arr.shape # 创建RGB图，纯蓝底 (R,G,B) = (0,0,255) rgb_img = np.zeros((height, width, 3), dtype=np.uint8) for y in range(height): for x in range(width): r, g, b = 0, 0, 255 cloud_intensity = arr[y, x] # 0~255 cloud_intensity = cloud_intensity - 30 if cloud_intensity \u0026lt; 100: cloud_intensity = max(cloud_intensity - 40, 0) # 线性混合，cloud_intensity 代表白云强度 (0~255) # 先计算权重：cloud_intensity / 255 w = cloud_intensity / 255 r = int(r * (1 - w) + w * 255) g = int(g * (1 - w) + w * 255) b = int(b * (1 - w) + w * 255) rgb_img[y, x, 0] = r rgb_img[y, x, 1] = g rgb_img[y, x, 2] = b # 直接保存uint8数组 im = Image.fromarray(rgb_img) im.save(\u0026#39;perlin_cloud.png\u0026#39;) 云层效果如图：\nUnity Noise Editor 在 Unity 中安装 Terrain Tools 工具后，在 Window \u0026gt; Terrain \u0026gt; Edit Noise 中可以找到噪声生成器，它可以直接生成包含 Perlin Noise 在内的各种噪声，并导出为纹理。\n或者，也可以直接在Unity Shader Graph里面找到Gradient Noise。\nPerlin, K. (1985). An image synthesizer. ACM Siggraph Computer Graphics, 19(3), 287-296.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPerlin Noise wiki, https://en.wikipedia.org/wiki/Perlin_noise\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRoger Eastman. (2019). CMSC425.01 Spring 2019 Lecture 20: Perlin noise I. University of Maryland. https://www.cs.umd.edu/class/spring2019/cmsc425/handouts/CMSC425Day20.pdf\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKen Perlin. (2022). Improved Noise reference implementation. https://mrl.cs.nyu.edu/~perlin/noise/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPerlin, K. (2002, July). Improving noise. In Proceedings of the 29th annual conference on Computer graphics and interactive techniques (pp. 681-682).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://cronrpc.github.io/zh/posts/perlin-noise-generator/","summary":"\u003ch2 id=\"perlin-noise-介绍\"\u003ePerlin Noise 介绍\u003c/h2\u003e\n\u003cp\u003ePerlin 噪声（Perlin Noise）是由 Ken Perlin 在 1983 年为电影《Tron》开发的一种平滑伪随机噪声算法\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e。它能够生成具有自然纹理的随机模式，广泛用于计算机图形学中模拟云彩、地形、火焰、木纹、水流等自然现象\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\u003cp\u003e与普通白噪声不同，Perlin 噪声具有空间相关性：相邻采样点的值变化平滑，没有突兀的跳变。这种平滑特性使得它生成的纹理更像自然界的连续变化。\u003c/p\u003e","title":"Perlin Noise Generator"},{"content":"本文仅聚焦于如下几个问题：\n从三角级数展开，过渡到欧拉形式的傅里叶变换 什么是离散傅里叶变换 什么是2D傅里叶变换 从2D傅里叶变换，解释到2D离散傅里叶变换 如何对图像进行2D傅里叶变换 2D傅里叶变换的周期性问题 从2D傅里叶变换的周期性理解傅里叶2D频谱图的中心化 傅里叶级数 傅里叶级数是一种数学工具，它表示一个周期函数为一组正弦和余弦函数的无穷和。\n三角级数展开 傅里叶变换最初是基于三角级数展开，即周期函数可以表示为一系列正弦和余弦函数的线性组合：\n$$ f(t) = a_0 + \\sum_{n=1}^{\\infty} a_n \\cos(n\\omega_0 t) + b_n \\sin(n\\omega_0 t) $$\n其中 $\\omega_0 = \\frac{2\\pi}{T}$ 是基本频率。\n复指数形式 利用欧拉公式：\n$$ \\cos(x) = \\frac{e^{ix} + e^{-ix}}{2}, \\quad \\sin(x) = \\frac{e^{ix} - e^{-ix}}{2i} $$\n可以将傅里叶级数改写为复指数形式：\n$$ f(t) = \\sum_{n=-\\infty}^{\\infty} c_n e^{in\\omega_0 t} $$\n其中 $c_n$ 是复数系数，封装了正弦和余弦部分的信息。欧拉形式的傅里叶表示更对称、更易于处理，也为后续推广到连续和多维情况提供了基础。\n在这里，$n$的取值范围变成了$-\\infty$到$\\infty$。\n离散傅里叶变换 DFT 离散傅里叶变换（Discrete Fourier Transform，简称 DFT）是傅里叶分析的一个重要分支，它的作用是将离散的有限长度信号（通常是数字信号）从时间域/空间域转换到频率域，表示成一组复数频率分量的叠加。\n实际中我们处理的是有限、离散的数据。离散傅里叶变换（DFT）定义如下：\n$$ X[k] = \\sum_{n=0}^{N-1} x[n] \\cdot e^{-i \\frac{2\\pi}{N}kn}, \\quad k = 0, 1, \\dots, N-1 $$\n对应的逆变换为：\n$$ x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\cdot e^{i \\frac{2\\pi}{N}kn} $$\nDFT 把时间域信号 $x[n]$ 映射到频域 $X[k]$，每个 $X[k]$ 对应一个频率分量的幅度和相位。\n负频率、周期重排 离散傅里叶变换中，可以有负频率。\n虽然 DFT 的索引 $k$ 是非负整数，但傅里叶频率具有模 $N$ 的周期性。\n也就是说：\n$$ e^{-j \\frac{2\\pi}{N} k n} = e^{-j \\frac{2\\pi}{N} (k + mN) n}, \\quad \\forall m \\in \\mathbb{Z} $$\n因此，频率 $k = N - 1$ 实际上等价于频率 $-1$，频率 $k = N - 2$ 等价于 $-2$，以此类推。\n我们可以将频率索引重新解释为从负频率到正频率：\n$$ k = -\\frac{N}{2}, \\dots, -1, 0, 1, \\dots, \\frac{N}{2} - 1 \\quad (\\text{当 } N \\text{ 为偶数时}) $$\n这种方式可以通过频谱的中心化重排，使得结果更符合频率对称直觉。\n在后面的对图像的2D傅里叶变换后，频谱图通过中心化重排后，将低频区域全部变换到中央。\n2D傅里叶变换 傅里叶变换可以从将原本的1D形式，扩展到2D形式。\n什么是2D傅里叶变换 连续2D傅里叶变换的定义如下，对于一个连续函数 $f(x, y)$：\n$$ F(u, v) = \\iint_{-\\infty}^{\\infty} f(x, y) \\cdot e^{-i2\\pi (ux + vy)} , dx,dy $$\n其逆变换为：\n$$ f(x, y) = \\iint_{-\\infty}^{\\infty} F(u, v) \\cdot e^{i2\\pi (ux + vy)} , du,dv $$\n其中 $(x, y)$ 是空间域坐标，$(u, v)$ 是频率域坐标。变换结果 $F(u, v)$ 描述了信号中每个频率分量的幅值和相位。\n2D 离散傅里叶变换 离散情况下，对于一个 $M \\times N$ 的二维离散函数 $f[m, n]$，其二维离散傅里叶变换（2D DFT）定义为：\n$$ F[k, l] = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f[m, n] \\cdot e^{-i 2\\pi \\left( \\frac{km}{M} + \\frac{ln}{N} \\right)} $$\n其逆变换为：\n$$ f[m, n] = \\frac{1}{MN} \\sum_{k=0}^{M-1} \\sum_{l=0}^{N-1} F[k, l] \\cdot e^{i 2\\pi \\left( \\frac{km}{M} + \\frac{ln}{N} \\right)} $$\n2D傅里叶变换的周期性 类似于1D DFT，2D DFT 也具有周期性：\n$$ F[k + M, l] = F[k, l], \\quad F[k, l + N] = F[k, l] $$\n这意味着频谱在两个方向（水平和垂直）上都是周期性的。\nDFT 中的频率索引 $k$ 和 $l$ 取值范围是 $0$ 到 $M-1$ 和 $N-1$，但这些索引并不是单纯的“正频率”，它们是模周期的。\n因为周期是 $M$ 和 $N$，所以后半部分可以看作对应的负频率分量。具体来说，当索引 $k \u0026gt; \\frac{M}{2}$ 时，实际频率等价于 $k - M$ 对应的负频率；同理，当索引 $l \u0026gt; \\frac{N}{2}$ 时，频率等价于 $l - N$ 对应的负频率。这样，频率索引的范围在 $[0, M-1]$ 和 $[0, N-1]$ 上循环，形成正负频率对称的结构。\n如何对图像进行2D傅里叶变换 Python 中可以使用 numpy 或 opencv 等库方便地进行 2D 傅里叶变换。例如，使用 NumPy：\nimport numpy as np import matplotlib.pyplot as plt from PIL import Image # 加载图像并转换为灰度 img = Image.open(\u0026#39;doge.jpg\u0026#39;).convert(\u0026#39;L\u0026#39;) f = np.array(img) # 计算2D傅里叶变换 F = np.fft.fft2(f) # 幅度谱与相位谱 magnitude_spectrum = np.abs(F) phase_spectrum = np.angle(F) log_magnitude = np.log(1 + magnitude_spectrum) # 创建子图 fig, axs = plt.subplots(1, 3, figsize=(15, 5)) # 原始图像 axs[0].imshow(f, cmap=\u0026#39;gray\u0026#39;) axs[0].set_title(\u0026#39;Original Image\u0026#39;) axs[0].axis(\u0026#39;off\u0026#39;) # 幅度谱 axs[1].imshow(log_magnitude, cmap=\u0026#39;gray\u0026#39;) axs[1].set_title(\u0026#39;Magnitude Spectrum (log)\u0026#39;) axs[1].axis(\u0026#39;off\u0026#39;) # 相位谱 im = axs[2].imshow(phase_spectrum, cmap=\u0026#39;gray\u0026#39;) axs[2].set_title(\u0026#39;Phase Spectrum\u0026#39;) axs[2].axis(\u0026#39;off\u0026#39;) # 添加 colorbar 到相位谱 fig.colorbar(im, ax=axs[2], shrink=0.7) plt.tight_layout() plt.show() 运行后可以看到幅度谱和相位谱，这里需要注意的一点在于，\n逆变换还原图像（频率+相位） 傅里叶变换的结果是复数，包含了幅度（Magnitude）和相位（Phase）信息。只保留其中之一就不能完整还原图像。\n还原图像的方式如下：\nimport numpy as np import matplotlib.pyplot as plt from PIL import Image # 加载图像并转换为灰度 img = Image.open(\u0026#39;doge.jpg\u0026#39;).convert(\u0026#39;L\u0026#39;) f = np.array(img) # 计算2D傅里叶变换 F = np.fft.fft2(f) # 进行逆傅里叶变换 recovered = np.fft.ifft2(F) recovered_real = np.real(recovered) plt.imshow(recovered_real, cmap=\u0026#39;gray\u0026#39;) plt.title(\u0026#39;Recovered Image from IFFT\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.show() 逆变换后应该和原图一样。\n频谱图中心化 为了更清晰地观察频率分布，我们通常对频谱进行中心化，使低频位于中心，高频分布在周围。\n中心化操作可以使用 np.fft.fftshift：\nimport cv2 import numpy as np import matplotlib.pyplot as plt img = cv2.imread(\u0026#39;doge.jpg\u0026#39;, cv2.IMREAD_GRAYSCALE) f = np.fft.fft2(img) fshift = np.fft.fftshift(f) magnitude_spectrum = 20 * np.log(np.abs(fshift) + 1) plt.figure(figsize=(12, 6)) plt.subplot(1, 2, 1) plt.title(\u0026#39;Original Image\u0026#39;) plt.imshow(img, cmap=\u0026#39;gray\u0026#39;) plt.subplot(1, 2, 2) plt.title(\u0026#39;Magnitude Spectrum\u0026#39;) plt.imshow(magnitude_spectrum, cmap=\u0026#39;gray\u0026#39;) plt.show() 此时频谱图将低频成分移到了中心，更易于观察纹理和方向性等信息。\n中心大致可以表示轮廓信息，而细节纹理是高频信息位于边缘。\n","permalink":"https://cronrpc.github.io/zh/posts/2d-fourier-transform/","summary":"\u003cp\u003e本文仅聚焦于如下几个问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e从三角级数展开，过渡到欧拉形式的傅里叶变换\u003c/li\u003e\n\u003cli\u003e什么是离散傅里叶变换\u003c/li\u003e\n\u003cli\u003e什么是2D傅里叶变换\u003c/li\u003e\n\u003cli\u003e从2D傅里叶变换，解释到2D离散傅里叶变换\u003c/li\u003e\n\u003cli\u003e如何对图像进行2D傅里叶变换\u003c/li\u003e\n\u003cli\u003e2D傅里叶变换的周期性问题\u003c/li\u003e\n\u003cli\u003e从2D傅里叶变换的周期性理解傅里叶2D频谱图的中心化\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"傅里叶级数\"\u003e傅里叶级数\u003c/h2\u003e\n\u003cp\u003e傅里叶级数是一种数学工具，它表示一个周期函数为一组正弦和余弦函数的无穷和。\u003c/p\u003e","title":"2D Fourier Transform"}]